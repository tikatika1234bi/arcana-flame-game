<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Arcana Flame - Full Screen Layout</title>
    <style>
        /* --- åŸºæœ¬è¨­å®š --- */
        :root { --bg-color: #0d0d0d; --panel-bg: #1f1f1f; --text-color: #e0e0e0; --accent-blue: #4a90e2; --accent-red: #e24a4a; --highlight: #ffd700; --sidebar-width: 260px; }
        body { margin: 0; background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        
        /* å…¨ç”»é¢ã‚³ãƒ³ãƒ†ãƒŠ */
        #app { display: flex; width: 100vw; height: 100vh; background: #000; }
        .hidden { display: none !important; }
        
        /* --- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ (è©³ç´° & ãƒ­ã‚°) --- */
        #sidebar {
            width: var(--sidebar-width);
            background: #181818;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            z-index: 20;
        }

        /* è©³ç´°è¡¨ç¤ºã‚¨ãƒªã‚¢ */
        #card-detail-view {
            flex: 0 0 320px; /* å›ºå®šé«˜ã• */
            background: #252525;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .detail-name { font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 10px; border-bottom: 1px solid #555; width: 100%; padding-bottom: 5px; }
        .detail-icon { font-size: 60px; margin: 10px 0; text-shadow: 0 0 10px rgba(255,255,255,0.2); }
        .detail-text { font-size: 13px; color: #ccc; line-height: 1.4; text-align: left; width: 100%; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; flex-grow: 1; }
        .detail-stats { display: flex; justify-content: space-around; width: 100%; font-size: 20px; font-weight: bold; margin-top: 10px; }
        
        /* ãƒ­ã‚°ã‚¨ãƒªã‚¢ (ã‚µã‚¤ãƒ‰ãƒãƒ¼ä¸‹éƒ¨) */
        #log-panel {
            flex: 1;
            background: #111;
            border: 1px solid #444;
            border-radius: 5px;
            overflow-y: auto;
            padding: 5px;
            font-size: 11px;
            color: #bbb;
            display: flex;
            flex-direction: column-reverse; /* æ–°ã—ã„ãƒ­ã‚°ã‚’ä¸‹ã«è¡¨ç¤ºã•ã›ã‚‹ãŒã€flexã§ä¸‹è©°ã‚ã«ã™ã‚‹ */
        }
        .log-line { border-bottom: 1px solid #333; margin-bottom: 3px; padding-bottom: 2px; }

        /* --- ãƒ¡ã‚¤ãƒ³ãƒœãƒ¼ãƒ‰ (å³å´) --- */
        #main-board {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: radial-gradient(circle at center, #222 0%, #000 100%);
        }

        /* æ•µã‚¨ãƒªã‚¢ãƒ»è‡ªåˆ†ã‚¨ãƒªã‚¢ (ä¼¸ç¸®ã—ã¦ç”»é¢ã‚’åŸ‹ã‚ã‚‹) */
        .field-section {
            flex: 1; /* å‡ç­‰ã«åºƒãŒã‚‹ */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .enemy-area { background: rgba(100, 30, 30, 0.15); }
        .player-area { background: rgba(30, 60, 100, 0.15); }

        .row { display: flex; justify-content: center; gap: 15px; align-items: center; min-height: 130px; }

        /* æ‰‹æœ­ã‚¨ãƒªã‚¢ (æœ€ä¸‹éƒ¨å›ºå®š) */
        .hand-container {
            height: 130px;
            background: rgba(20,20,20,0.95);
            border-top: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 5px 20px;
            overflow-x: auto;
        }

        /* --- ã‚«ãƒ¼ãƒ‰ & ã‚¹ãƒ­ãƒƒãƒˆ --- */
        .slot {
            width: 90px;
            height: 125px;
            border: 2px dashed #555;
            border-radius: 8px;
            position: relative;
            transition: 0.2s;
            background: rgba(255,255,255,0.02);
        }
        .slot.reaction { transform: scale(0.85); opacity: 0.7; border-color: #665; }
        .slot.valid { background: rgba(255, 215, 0, 0.15); border-color: var(--highlight); cursor: pointer; animation: pulse 1s infinite; }
        .slot.attack-target { background: rgba(255, 50, 50, 0.2); border-color: var(--accent-red); cursor: crosshair; }

        /* ã‚«ãƒ¼ãƒ‰ãƒ‡ã‚¶ã‚¤ãƒ³ */
        .card {
            width: 100%; height: 100%;
            background: var(--panel-bg);
            border: 2px solid #777;
            border-radius: 6px;
            display: flex; flex-direction: column;
            padding: 3px; box-sizing: border-box;
            cursor: pointer; position: relative;
            box-shadow: 0 5px 10px rgba(0,0,0,0.5);
            transition: transform 0.15s;
        }
        .card:hover { transform: translateY(-5px); border-color: #aaa; z-index: 10; }
        .card.selected { border-color: var(--highlight); box-shadow: 0 0 15px var(--highlight); transform: translateY(-10px); z-index: 100; }
        .card.exhausted { filter: grayscale(1) brightness(0.6); cursor: default; }
        .card.face-down { background: repeating-linear-gradient(135deg, #222, #222 10px, #333 10px, #333 20px); border-color: #444; }
        .card.face-down * { display: none; }
        
        .card.unit { border-top: 4px solid #a3b1b5; }
        .card.spell { border-top: 4px solid #b580d1; }
        .card.reaction { border-top: 4px solid #e08e45; }

        .card-name { font-size: 10px; font-weight: bold; text-align: center; white-space: nowrap; overflow: hidden; color: #fff; margin-bottom: 2px;}
        .card-art { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 32px; background: rgba(0,0,0,0.3); border-radius: 3px; margin-bottom: 2px; }
        .card-mini-stats { display: flex; justify-content: space-between; font-weight: bold; font-size: 12px; padding: 0 4px; background: rgba(0,0,0,0.5); border-radius: 2px; }
        
        .val-atk { color: #ff8888; } .val-def { color: #88aaff; }

        /* --- UIãƒ‘ãƒ¼ãƒ„ --- */
        .center-hud {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            pointer-events: none;
            text-align: center;
        }
        #phase-badge { background: var(--accent-blue); color: #fff; padding: 5px 25px; border-radius: 20px; font-weight: bold; font-size: 24px; box-shadow: 0 4px 15px rgba(0,0,0,0.8); margin-bottom: 15px; display: inline-block; }
        #btn-next { pointer-events: auto; background: #eee; color: #111; padding: 10px 40px; font-size: 18px; border: 3px solid #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        
        .lp-badge { position: absolute; font-weight: bold; font-size: 16px; background: rgba(0,0,0,0.8); padding: 5px 15px; border-radius: 5px; border: 1px solid #555; z-index: 10; }
        .enemy-lp { top: 15px; left: 15px; color: var(--accent-red); }
        .player-lp { bottom: 15px; left: 15px; color: var(--accent-blue); }

        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .menu-btn { padding: 10px 20px; background: #444; color: #fff; margin: 5px; min-width: 140px; border: 1px solid #666; font-size: 16px; cursor: pointer; }
        .gacha-btn { padding: 15px 40px; font-size: 18px; background: linear-gradient(45deg, #f1c40f, #e67e22); color: #000; margin: 10px; cursor: pointer; border:none; font-weight:bold; }
        
        /* Animations */
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        .float-txt { position: absolute; font-weight: bold; font-size: 24px; animation: floatUp 1.2s forwards; z-index: 150; pointer-events: none; text-shadow: 2px 2px 0 #000; }
        @keyframes floatUp { 0% { transform:translateY(0) scale(1); opacity:1; } 100% { transform:translateY(-60px) scale(1.5); opacity:0; } }
    </style>
</head>
<body>

<!-- 1. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»é¢ç¾¤ -->
<div id="login-screen" class="overlay">
    <h1 style="color:var(--highlight); font-size:48px; margin-bottom:10px;">ARCANA FLAME</h1>
    <button class="gacha-btn" onclick="Auth.login()">Googleã§ãƒ­ã‚°ã‚¤ãƒ³</button>
</div>

<div id="nickname-screen" class="overlay hidden">
    <h2>ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ç™»éŒ²</h2>
    <input type="text" id="nickname-input" placeholder="8æ–‡å­—ä»¥å†…" maxlength="8" style="padding:10px; font-size:18px; text-align:center;">
    <button class="menu-btn" onclick="Auth.setNickname()">æ±ºå®š</button>
</div>

<div id="menu-screen" class="overlay hidden">
    <div style="text-align:right; width:100%; padding:10px; box-sizing:border-box; color:#888;">
        <span id="display-name">Guest</span> | ğŸ’ <span id="menu-stones">0</span>
    </div>
    <h2>MAIN MENU</h2>
    
    <div style="background:#222; padding:20px; border-radius:10px; text-align:center; margin-bottom:20px;">
        <h3>ğŸ”® ã‚«ãƒ¼ãƒ‰ãƒ‘ãƒƒã‚¯</h3>
        <button class="gacha-btn" onclick="Gacha.pull()">100ğŸ’ ã§å¼•ã</button>
        <button id="bonus-btn" class="menu-btn" onclick="Gacha.addFreeStones()">ãƒœãƒ¼ãƒŠã‚¹å—å–</button>
        <div id="gacha-result" style="height:40px; margin-top:10px; color:#ffd700;"></div>
    </div>

    <div>
        <h3>âš”ï¸ ãƒãƒˆãƒ«é–‹å§‹</h3>
        <button class="menu-btn" onclick="Game.start(0)">ğŸ”¥ ãƒ‰ãƒ©ã‚´ãƒ³</button>
        <button class="menu-btn" onclick="Game.start(1)">ğŸ”® é­”è¡“å¸«</button>
        <button class="menu-btn" onclick="Game.start(2)">ğŸ›¡ï¸ ã‚¬ãƒ¼ãƒ‡ã‚£ã‚¢ãƒ³</button>
    </div>
    <button class="menu-btn" style="background:#333; font-size:12px; margin-top:20px;" onclick="Auth.logout()">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
</div>

<div id="result-screen" class="overlay hidden">
    <h1 id="result-msg" style="font-size:64px;"></h1>
    <button class="menu-btn" onclick="location.reload()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
</div>

<!-- 2. ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ç”»é¢ (2ã‚«ãƒ©ãƒ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ) -->
<div id="game-app" class="hidden" style="display:flex;">
    
    <!-- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
    <div id="sidebar">
        <!-- ã‚«ãƒ¼ãƒ‰è©³ç´° -->
        <div id="card-detail-view">
            <div style="color:#666; padding-top:50px;">ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠ</div>
        </div>
        <!-- ãƒ­ã‚° -->
        <div id="log-panel">
            <div class="log-line">Game Ready...</div>
        </div>
    </div>

    <!-- å³ãƒ¡ã‚¤ãƒ³ãƒœãƒ¼ãƒ‰ -->
    <div id="main-board">
        <!-- æ•µãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ -->
        <div class="field-section enemy-area">
            <div class="lp-badge enemy-lp">CPU: <span id="cpu-lp">12</span></div>
            <div class="row" id="cpu-units"><div class="slot" data-i="0"></div><div class="slot" data-i="1"></div><div class="slot" data-i="2"></div></div>
            <div class="row" id="cpu-reacts" style="min-height:90px;"><div class="slot reaction" data-i="0"></div><div class="slot reaction" data-i="1"></div></div>
        </div>

        <!-- ã‚»ãƒ³ã‚¿ãƒ¼HUD -->
        <div class="center-hud">
            <div id="phase-badge">START</div><br>
            <button id="btn-next" onclick="Game.nextPhase()">Start</button>
        </div>

        <!-- è‡ªåˆ†ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ -->
        <div class="field-section player-area">
            <div class="row" id="player-reacts" style="min-height:90px;"><div class="slot reaction" data-i="0"></div><div class="slot reaction" data-i="1"></div></div>
            <div class="row" id="player-units"><div class="slot" data-i="0"></div><div class="slot" data-i="1"></div><div class="slot" data-i="2"></div></div>
            <div class="lp-badge player-lp">YOU: <span id="player-lp">12</span></div>
        </div>

        <!-- æ‰‹æœ­ -->
        <div class="hand-container" id="player-hand"></div>
    </div>

    <button class="menu-btn" style="position:absolute; top:10px; right:10px; z-index:500; min-width:60px; font-size:12px;" onclick="location.reload()">RETIRE</button>
</div>

<!-- Scripts -->
<script type="module">
    // Firebase Setup
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { getAuth, signInWithPopup, signOut, GoogleAuthProvider, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, arrayUnion, increment } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

    // â˜…â˜…â˜… Firebase Config (æ›¸ãæ›ãˆã¦ãã ã•ã„) â˜…â˜…â˜…
const firebaseConfig = {
  apiKey: "AIzaSyCNgyBeSzbc74e6iWNnY0irswl24ciAfcg",
  authDomain: "arcana-flame-game.firebaseapp.com",
  projectId: "arcana-flame-game",
  storageBucket: "arcana-flame-game.firebasestorage.app",
  messagingSenderId: "562804440230",
  appId: "1:562804440230:web:26f7bd08ea47d39ad80867",
  measurementId: "G-XT2EDR06R1"
};

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();

    // --- Game Constants & DB ---
    const TYPE = { UNIT: 'UNIT', SPELL: 'SPELL', REACT: 'REACT' };
    const TARGET = { NONE: 'NONE', ENEMY: 'ENEMY', ALLY: 'ALLY', ANY: 'ANY' };
    const PHASE = { DRAW: 'DRAW', MAIN: 'MAIN', BATTLE: 'BATTLE', END: 'END' };

    // Card Database (Descriptions added for detail view)
    const DB = {
        'd01': { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ãƒ»ãƒ‰ãƒ©ã‚´ãƒ³', type: TYPE.UNIT, atk: 3, def: 3, icon: 'ğŸ²', desc: 'æ¨™æº–çš„ãªãƒ‰ãƒ©ã‚´ãƒ³ã€‚ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„ã€‚', target: TARGET.NONE },
        'd02': { name: 'ãƒœãƒ«ã‚«ãƒ‹ãƒƒã‚¯', type: TYPE.UNIT, atk: 4, def: 2, icon: 'ğŸ¦–', desc: 'æ”»æ’ƒåŠ›ãŒé«˜ã„ãŒè€ä¹…ã¯ä½ã„ã€‚ã‚¢ã‚¿ãƒƒã‚«ãƒ¼ã€‚', target: TARGET.NONE },
        'd03': { name: 'ã‚¬ãƒ¼ãƒ‰ã‚¹ã‚±ã‚¤ãƒ«', type: TYPE.UNIT, atk: 2, def: 5, icon: 'ğŸ›¡ï¸', desc: 'é«˜ã„é˜²å¾¡åŠ›ã‚’æŒã¤å£å½¹ã€‚', target: TARGET.NONE },
        'd04': { name: 'ãƒ«ãƒ“ãƒ¼ãƒ›ãƒ¼ãƒ³', type: TYPE.UNIT, atk: 3, def: 4, icon: 'ğŸ‚', desc: 'æ”»å®ˆã®ãƒãƒ©ãƒ³ã‚¹ã«å„ªã‚ŒãŸä¸­å …ãƒ¦ãƒ‹ãƒƒãƒˆã€‚', target: TARGET.NONE },
        'd05': { name: 'ã‚½ãƒ¼ãƒ©ãƒ¼ãƒ–ãƒ¬ã‚¤ã‚º', type: TYPE.UNIT, atk: 5, def: 3, icon: 'ğŸŒ', desc: 'ã€å¬å–šæ™‚ã€‘æ•µãƒ¦ãƒ‹ãƒƒãƒˆ1ä½“ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚', effect: 'dmg_2', target: TARGET.NONE },
        's01': { name: 'ãƒ‰ãƒ©ã‚´ãƒ³ãƒ•ã‚©ãƒ¼ã‚¹', type: TYPE.SPELL, icon: 'ğŸ’ª', desc: 'å‘³æ–¹1ä½“ã®ATKã‚’ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§+2ã™ã‚‹ã€‚', effect: 'buff_atk_2_turn', target: TARGET.ALLY },
        's02': { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ãƒãƒ¼ã‚¹ãƒˆ', type: TYPE.SPELL, icon: 'ğŸ”¥', desc: 'æ•µãƒ¦ãƒ‹ãƒƒãƒˆ1ä½“ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚', effect: 'dmg_3', target: TARGET.ENEMY },
        's03': { name: 'ç†±é¢¨ã®å·ä»¤', type: TYPE.SPELL, icon: 'ğŸŒ¬ï¸', desc: 'å…¨ã¦ã®å‘³æ–¹ãƒ¦ãƒ‹ãƒƒãƒˆã®ATKã‚’ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§+1ã™ã‚‹ã€‚', effect: 'all_atk_1_turn', target: TARGET.NONE },
        'r01': { name: 'ãƒ‰ãƒ©ã‚´ãƒ³ã®å’†å“®', type: TYPE.REACT, icon: 'ğŸ“¢', desc: 'ã€è¢«æ”»æ’ƒæ™‚ã€‘ãã®å‘³æ–¹ã®ATKã‚’ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§+1ã™ã‚‹ã€‚', trigger: 'attacked', effect: 'react_atk_1' },

        'm01': { name: 'ã‚¢ãƒ—ãƒ¬ãƒ³ãƒ†ã‚£ã‚¹', type: TYPE.UNIT, atk: 2, def: 2, icon: 'ğŸ§™', desc: 'ã€å¬å–šæ™‚ã€‘å‘³æ–¹ãƒ¦ãƒ‹ãƒƒãƒˆ1ä½“ã®DEFã‚’+1ã™ã‚‹(æ°¸ç¶š)ã€‚', effect: 'buff_def_1', target: TARGET.NONE },
        'm02': { name: 'ã‚¯ãƒ­ãƒãƒãƒ³ã‚µãƒ¼', type: TYPE.UNIT, atk: 1, def: 3, icon: 'â³', desc: 'ã€æ°¸ç¶šã€‘ã‚¹ãƒšãƒ«ã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’1è»½æ¸›ã™ã‚‹ã€‚', passive: 'spell_resist', target: TARGET.NONE },
        'm03': { name: 'ãƒ«ãƒ¼ãƒ³ä½¿ã„', type: TYPE.UNIT, atk: 2, def: 3, icon: 'âœ¨', desc: 'ã€æ°¸ç¶šã€‘å‘³æ–¹ãƒ¦ãƒ‹ãƒƒãƒˆå…¨å“¡ã®ATKã‚’+1ã™ã‚‹ã€‚', passive: 'aura_atk_1', target: TARGET.NONE },
        'm04': { name: 'ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ã‚¹ãƒˆ', type: TYPE.UNIT, atk: 3, def: 2, icon: 'ğŸ“–', desc: 'ã€å¬å–šæ™‚ã€‘ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã€‚', effect: 'draw_1', target: TARGET.NONE },
        'm05': { name: 'å¤§è³¢è€…ã‚ªãƒ«ãƒ‡ã‚£ãƒ³', type: TYPE.UNIT, atk: 4, def: 4, icon: 'ğŸ‘´', desc: 'ã€å¬å–šæ™‚ã€‘æ•µ1ä½“ã®DEFã‚’-2ã™ã‚‹(å®Ÿè³ª2ãƒ€ãƒ¡ãƒ¼ã‚¸)ã€‚', effect: 'debuff_def_2', target: TARGET.NONE },
        's11': { name: 'å°å°ã®é–ƒå…‰', type: TYPE.SPELL, icon: 'ğŸ”’', desc: 'æ•µ1ä½“ã‚’ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§æ”»æ’ƒä¸èƒ½ã«ã™ã‚‹ã€‚', effect: 'lock', target: TARGET.ENEMY },
        's12': { name: 'ãƒ‡ã‚£ã‚¹ã‚¸ãƒ£ãƒ³ã‚¯', type: TYPE.SPELL, icon: 'ğŸš«', desc: 'æ•µ1ä½“ã®ATKã‚’ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§0ã«ã™ã‚‹ã€‚', effect: 'zero_atk', target: TARGET.ENEMY },
        's13': { name: 'é­”å°è§£æ', type: TYPE.SPELL, icon: 'ğŸ“š', desc: 'ã‚«ãƒ¼ãƒ‰ã‚’2æšå¼•ãã€‚', effect: 'draw_2', target: TARGET.NONE },
        's14': { name: 'ãƒãƒŠã‚·ãƒ¼ãƒ«ãƒ‰', type: TYPE.SPELL, icon: 'ğŸ›¡ï¸', desc: 'å‘³æ–¹1ä½“ã«ã€Œã“ã®ã‚¿ãƒ¼ãƒ³ç ´å£Šã•ã‚Œãªã„ã€ã‚’ä»˜ä¸ã™ã‚‹ã€‚', effect: 'shield', target: TARGET.ALLY },
        'r11': { name: 'åè»¢ã®çµç•Œ', type: TYPE.REACT, icon: 'ğŸ›‘', desc: 'ã€ç›¸æ‰‹ã‚¹ãƒšãƒ«ç™ºå‹•æ™‚ã€‘ãã®ã‚¹ãƒšãƒ«ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ã€‚', trigger: 'spell', effect: 'negate' },
        'r12': { name: 'ã‚¢ã‚¹ãƒˆãƒ©ãƒ«', type: TYPE.REACT, icon: 'ğŸŒŒ', desc: 'ã€æ•µãŒ3ä½“ä»¥ä¸Šã€‘æ•µ2ä½“ã‚’æ‰‹æœ­ã«æˆ»ã™ã€‚', trigger: 'full_field', effect: 'bounce_2' },

        'b01': { name: 'ã‚·ãƒ¼ãƒ«ãƒ‰ãƒ™ã‚¢', type: TYPE.UNIT, atk: 2, def: 5, icon: 'ğŸ»', desc: 'éå¸¸ã«é«˜ã„è€ä¹…åŠ›ã‚’æŒã¤å£ã€‚', target: TARGET.NONE },
        'b02': { name: 'ã‚¢ã‚¤ã‚¢ãƒ³ãƒ•ã‚¡ãƒ³ã‚°', type: TYPE.UNIT, atk: 3, def: 4, icon: 'ğŸº', desc: 'æ”»å®ˆã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„é‡ç£ã€‚', target: TARGET.NONE },
        'b03': { name: 'ãƒªãƒšã‚¢ãƒ›ãƒ¼ãƒ³', type: TYPE.UNIT, atk: 1, def: 4, icon: 'ğŸ¦„', desc: 'ã€å¬å–šæ™‚ã€‘å‘³æ–¹1ä½“ã®DEFã‚’+2ã™ã‚‹ã€‚', effect: 'buff_def_2', target: TARGET.NONE },
        'b04': { name: 'ãƒ­ãƒƒã‚¯ã‚¸ãƒ£ã‚¦', type: TYPE.UNIT, atk: 3, def: 6, icon: 'ğŸ—¿', desc: 'æœ€é«˜ã‚¯ãƒ©ã‚¹ã®DEFã‚’æŒã¤ã€‚', target: TARGET.NONE },
        'b05': { name: 'ã‚¿ã‚¤ã‚¿ãƒ³', type: TYPE.UNIT, atk: 4, def: 7, icon: 'ğŸ‘¹', desc: 'ã€æ°¸ç¶šã€‘æ”»æ’ƒã•ã‚ŒãŸæ™‚ã€æ”»æ’ƒè€…ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ä¸ãˆã‚‹ã€‚', passive: 'reflect', target: TARGET.NONE },
        's21': { name: 'ãƒ•ã‚©ãƒ¼ãƒˆãƒ¬ã‚¹', type: TYPE.SPELL, icon: 'ğŸ°', desc: 'å‘³æ–¹1ä½“ã®DEFã‚’+3ã™ã‚‹ã€‚', effect: 'buff_def_3', target: TARGET.ALLY },
        's22': { name: 'ã‚¹ãƒãƒƒã‚·ãƒ¥', type: TYPE.SPELL, icon: 'ğŸ”¨', desc: 'æ•µ1ä½“ã«2ãƒ€ãƒ¡ã€‚æ•µDEFãŒ5ä»¥ä¸Šãªã‚‰4ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚', effect: 'cond_dmg', target: TARGET.ENEMY },
        's23': { name: 'ãƒãƒªã‚¢ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', type: TYPE.SPELL, icon: 'ğŸŒ', desc: 'å‘³æ–¹å…¨å“¡ã®DEFã‚’ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§+1ã™ã‚‹ã€‚', effect: 'all_def_1_turn', target: TARGET.NONE },
        'r21': { name: 'å …ç‰¢ãªã‚‹åæ’ƒ', type: TYPE.REACT, icon: 'âš”ï¸', desc: 'ã€è¢«æ”»æ’ƒæ™‚ã€‘æ”»æ’ƒã—ã¦ããŸæ•µã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ä¸ãˆã‚‹ã€‚', trigger: 'attacked', effect: 'react_dmg_2' }
    };

    const DECK_LISTS = [
        ['d01','d01','d01', 'd02','d02','d02', 'd03','d03', 'd04','d04', 'd05','d05', 's01','s01', 's02','s02', 's03','s03', 'r01','r01'],
        ['m01','m01','m01', 'm02','m02', 'm03','m03','m03', 'm04','m04', 'm05','m05', 's11','s11', 's12','s12', 's13', 's14', 'r11', 'r12'],
        ['b01','b01','b01', 'b02','b02','b02', 'b03','b03', 'b04','b04', 'b05','b05', 's21','s21', 's22','s22', 's23','s23', 'r21','r21']
    ];

    // --- Auth & User ---
    window.Auth = {
        user: null, nickname: null,
        async login() { try { await signInWithPopup(auth, provider); } catch(e){ alert("Login Error"); } },
        async logout() { await signOut(auth); location.reload(); },
        async setNickname() {
            const name = document.getElementById('nickname-input').value.trim();
            if(!name) return alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            await updateDoc(doc(db, "users", this.user.uid), { nickname: name });
            this.nickname = name;
            document.getElementById('display-name').innerText = name;
            document.getElementById('nickname-screen').classList.add('hidden');
            document.getElementById('menu-screen').classList.remove('hidden');
        }
    };

    onAuthStateChanged(auth, async (user) => {
        if (user) {
            window.Auth.user = user;
            document.getElementById('login-screen').classList.add('hidden');
            await Gacha.loadUserData(user.uid);
            if (!window.Auth.nickname) document.getElementById('nickname-screen').classList.remove('hidden');
            else document.getElementById('menu-screen').classList.remove('hidden');
        }
    });

    // --- Gacha ---
    window.Gacha = {
        stones: 0, collection: [], lastBonusDate: null,
        async loadUserData(uid) {
            const docSnap = await getDoc(doc(db, "users", uid));
            if (docSnap.exists()) {
                const d = docSnap.data();
                this.stones = d.stones || 0;
                this.collection = d.collection || [];
                this.lastBonusDate = d.lastBonusDate;
                window.Auth.nickname = d.nickname;
            } else {
                this.stones = 3000;
                await setDoc(doc(db, "users", uid), { stones: 3000, collection: [], nickname: null });
            }
            this.updateUI();
        },
        updateUI() {
            document.getElementById('menu-stones').innerText = this.stones;
            if(window.Auth.nickname) document.getElementById('display-name').innerText = window.Auth.nickname;
            const btn = document.getElementById('bonus-btn');
            const today = new Date().toDateString();
            if(this.lastBonusDate === today) { btn.disabled=true; btn.innerText="å—å–æ¸ˆã¿"; }
            else { btn.disabled=false; btn.innerText="ãƒœãƒ¼ãƒŠã‚¹ (+500ğŸ’)"; }
        },
        async addFreeStones() {
            const today = new Date().toDateString();
            this.stones += 500; this.lastBonusDate = today;
            this.updateUI();
            await updateDoc(doc(db, "users", window.Auth.user.uid), { stones: increment(500), lastBonusDate: today });
        },
        async pull() {
            if(this.stones < 100) return alert("çŸ³ä¸è¶³");
            this.stones -= 100; this.updateUI();
            const keys = Object.keys(DB);
            const hit = keys[Math.floor(Math.random()*keys.length)];
            const d = DB[hit];
            document.getElementById('gacha-result').innerText = `GET: ${d.name}`;
            await updateDoc(doc(db, "users", window.Auth.user.uid), { stones: increment(-100), collection: arrayUnion(hit) });
        }
    };

    // --- Game Logic ---
    class Card {
        constructor(id, owner) {
            this.id = id; this.data = DB[id]; this.owner = owner;
            this.uid = Math.random().toString(36).substr(2, 9);
            this.baseAtk = this.data.atk||0; this.baseDef = this.data.def||0;
            this.atkModPermanent = 0; this.atkModTurn = 0; this.defModPermanent = 0; this.defModTurn = 0; this.damageTaken = 0;
            this.canAttack = true; this.hasAttacked = false; this.isLocked = false; this.destructionImmune = false;
        }
        get atk() { return Math.max(0, this.baseAtk + this.atkModPermanent + this.atkModTurn + (this.passiveAtk || 0)); }
        get def() { return (this.baseDef + this.defModPermanent + this.defModTurn) - this.damageTaken; }
        resetTurn() { this.hasAttacked = false; this.canAttack = !this.isLocked; this.isLocked = false; this.destructionImmune = false; this.atkModTurn = 0; this.defModTurn = 0; }
    }

    const AI = {
        act() {
            if(Game.turn !== 'cpu') return;
            const cpu = Game.cpu; const opp = Game.player;
            const units = cpu.hand.map((c,i)=>({c,i})).filter(o=>o.c.data.type === TYPE.UNIT);
            const playable = units.filter(o => !cpu.units.some(u => u && u.data.name === o.c.data.name));
            if(playable.length > 0 && cpu.summonCount < 2) {
                playable.sort((a,b) => (b.c.atk+b.c.def) - (a.c.atk+a.c.def));
                const slot = cpu.units.findIndex(u=>u===null);
                if(slot !== -1) { Game.playCard(cpu, playable[0].i, null, slot); setTimeout(()=>this.act(), 800); return; }
            }
            const spells = cpu.hand.map((c,i)=>({c,i})).filter(o=>o.c.data.type !== TYPE.UNIT);
            if(spells.length > 0) {
                const s = spells[0];
                if(s.c.data.type === TYPE.REACT) {
                    const slot = cpu.reacts.findIndex(r=>r===null);
                    if(slot !== -1) Game.playCard(cpu, s.i, null, slot);
                } else {
                    let t = null;
                    if(s.c.data.target === TARGET.ENEMY) t = Game.findBestTarget(opp.units, 'ATK');
                    if(s.c.data.target === TARGET.ALLY) t = Game.findBestTarget(cpu.units, 'ATK');
                    if(s.c.data.target === TARGET.NONE || t) Game.playCard(cpu, s.i, t);
                }
            }
            setTimeout(()=>Game.nextPhase(), 1200);
        },
        battle() {
            if(Game.turn !== 'cpu') return;
            const atts = Game.cpu.units.filter(u=>u && u.canAttack && !u.hasAttacked);
            if(atts.length === 0) { setTimeout(()=>Game.nextPhase(), 600); return; }
            atts.sort((a,b)=>b.atk - a.atk);
            const att = atts[0];
            const enemies = Game.player.units.map((u,i)=>({u,i})).filter(o=>o.u);
            let tIdx = -2;
            if(enemies.length === 0) tIdx = -1;
            else {
                const kills = enemies.filter(e => att.atk > e.u.def);
                if(kills.length > 0) { kills.sort((a,b)=>b.u.atk - a.u.atk); tIdx = kills[0].i; }
                else { const trades = enemies.filter(e => att.atk === e.u.def && e.u.atk >= att.atk); if(trades.length > 0) tIdx = trades[0].i; }
            }
            if(tIdx !== -2) Game.attack(att, tIdx); else att.hasAttacked = true;
            setTimeout(()=>this.battle(), 1000);
        }
    };

    window.Game = {
        player: null, cpu: null, turn: 'player', phase: PHASE.DRAW, selectedCard: null, selectedUnit: null, gameOver: false, firstTurn: true,
        start(deckIdx) {
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-app').style.display = 'flex'; // Ensure flex
            document.getElementById('game-app').classList.remove('hidden');
            
            const createPlayer = (id, dIdx) => ({ id, lp: 12, deck: this.shuffle(DECK_LISTS[dIdx].map(cid => new Card(cid, id))), hand: [], units: [null, null, null], reacts: [null, null], summonCount: 0 });
            this.player = createPlayer('player', deckIdx);
            this.cpu = createPlayer('cpu', (deckIdx + 1 + Math.floor(Math.random()*2)) % 3);
            for(let i=0; i<4; i++) { this.draw(this.player); this.draw(this.cpu); }
            this.turn = Math.random() < 0.5 ? 'player' : 'cpu';
            UI.log(`Battle Start! å…ˆæ”»: ${this.turn === 'player' ? 'YOU' : 'CPU'}`);
            this.startTurn();
        },
        shuffle(arr) { for(let i=arr.length-1; i>0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; },
        draw(p, amt=1) { for(let i=0; i<amt; i++) { if(p.deck.length > 0) p.hand.push(p.deck.pop()); else this.endGame(p.id === 'player' ? 'cpu' : 'player'); } },
        startTurn() {
            this.phase = PHASE.DRAW; const p = this.turn === 'player' ? this.player : this.cpu;
            p.summonCount = 0; [this.player, this.cpu].forEach(pl => pl.units.forEach(u => { if(u) u.resetTurn(); }));
            this.updateStats(); UI.update();
            setTimeout(() => {
                if(this.firstTurn) { this.firstTurn = false; UI.log("å…ˆæ”»1T:ãƒ‰ãƒ­ãƒ¼ãªã—"); } else this.draw(p);
                this.phase = PHASE.MAIN; UI.update();
                if(this.turn === 'cpu') AI.act();
            }, 800);
        },
        nextPhase() {
            if(this.gameOver) return;
            if(this.phase === PHASE.MAIN) { this.phase = PHASE.BATTLE; UI.update(); if(this.turn === 'cpu') AI.battle(); }
            else if(this.phase === PHASE.BATTLE) { this.phase = PHASE.END; this.turn = this.turn === 'player' ? 'cpu' : 'player'; this.startTurn(); }
        },
        playCard(p, handIdx, tUnit=null, sIdx=null) {
            const card = p.hand[handIdx]; if(!card) return;
            if(card.data.type === TYPE.UNIT) {
                if(p.summonCount >= 2) { UI.log("å¬å–šæ¨©ãªã—"); return; }
                if(p.units[sIdx] !== null || p.units.some(u => u && u.data.name === card.data.name)) { UI.log("å¬å–šä¸å¯"); return; }
            }
            const opp = p.id === 'player' ? this.cpu : this.player;
            if(card.data.type === TYPE.SPELL && this.checkReaction('spell', opp, null)) { p.hand.splice(handIdx, 1); UI.log("ç„¡åŠ¹åŒ–"); UI.update(); return; }
            p.hand.splice(handIdx, 1);
            if(card.data.type === TYPE.UNIT) { p.units[sIdx] = card; p.summonCount++; UI.log(`å¬å–š: ${card.data.name}`); this.resolveEffect(card, p, null); this.checkReaction('full_field', opp, null); }
            else if(card.data.type === TYPE.SPELL) { UI.log(`ç™ºå‹•: ${card.data.name}`); this.resolveEffect(card, p, tUnit); }
            else if(card.data.type === TYPE.REACT) { p.reacts[sIdx] = card; UI.log(`ã‚»ãƒƒãƒˆ: ${card.data.name}`); }
            this.updateStats(); UI.update();
        },
        attack(attacker, targetIdx) {
            if(!attacker.canAttack || attacker.hasAttacked) return;
            attacker.hasAttacked = true;
            const defOwner = attacker.owner === 'player' ? this.cpu : this.player;
            const defender = targetIdx === -1 ? null : defOwner.units[targetIdx];
            if(defender && this.checkReaction('attacked', defOwner, defender)) { if(!attacker) return; }
            if(!defender) {
                if(defOwner.units.some(u => u !== null)) { UI.log("å£ã‚ã‚Š"); return; }
                UI.log(`${attacker.data.name} ç›´æ¥æ”»æ’ƒ`); this.damagePlayer(defOwner, attacker.atk);
            } else {
                UI.log(`æˆ¦é—˜: ${attacker.atk} vs ${defender.def}`);
                if(defender.data.passive === 'reflect') { UI.log("åæ’ƒ"); this.damageUnit(attacker, 2); }
                if(attacker.atk > defender.def) { UI.log("æ’ƒç ´"); this.destroyUnit(defender); }
                else if (attacker.atk < defender.def) { UI.log("è¿”ã‚Šè¨ã¡"); this.destroyUnit(attacker); }
                else { UI.log("ç›¸æ‰“ã¡"); this.destroyUnit(attacker); this.destroyUnit(defender); }
            }
            this.updateStats(); UI.update();
        },
        resolveEffect(card, user, target) {
            const eff = card.data.effect; if(!eff) return;
            const opp = user.id === 'player' ? this.cpu : this.player;
            if(eff==='dmg_2') { const t = this.findBestTarget(opp.units, 'ATK'); if(t) this.damageUnit(t, 2); }
            else if(eff==='buff_def_1') card.defModPermanent += 1;
            else if(eff==='debuff_def_2') { const t = this.findBestTarget(opp.units, 'DEF'); if(t) this.damageUnit(t, 2); }
            else if(eff==='draw_1') this.draw(user, 1);
            else if(eff==='buff_def_2') card.defModPermanent += 2;
            else if(eff==='buff_atk_2_turn' && target) target.atkModTurn += 2;
            else if(eff==='dmg_3' && target) this.damageUnit(target, 3);
            else if(eff==='all_atk_1_turn') user.units.forEach(u=>{if(u) u.atkModTurn += 1;});
            else if(eff==='lock' && target) target.isLocked = true;
            else if(eff==='zero_atk' && target) target.atkModTurn = -target.baseAtk - target.atkModPermanent;
            else if(eff==='draw_2') this.draw(user, 2);
            else if(eff==='shield' && target) target.destructionImmune = true;
            else if(eff==='buff_def_3' && target) target.defModPermanent += 3;
            else if(eff==='cond_dmg' && target) { this.damageUnit(target, target.def >= 5 ? 4 : 2); }
            else if(eff==='all_def_1_turn') user.units.forEach(u=>{if(u) u.defModTurn += 1;});
            else if(eff==='react_atk_1' && target) target.atkModTurn += 1;
            else if(eff==='react_dmg_2') { const t = this.findBestTarget(opp.units, 'ATK'); if(t) this.damageUnit(t, 2); }
            else if(eff==='bounce_2') { let b = opp.units.filter(u=>u); for(let i=0;i<2;i++){ if(b.length===0)break; const idx=Math.floor(Math.random()*b.length); this.bounceUnit(b[idx]); b.splice(idx,1); } }
        },
        checkReaction(trigger, owner, targetUnit) {
            const idx = owner.reacts.findIndex(r => r && r.data.trigger === trigger); if(idx === -1) return false;
            const r = owner.reacts[idx];
            if(trigger==='full_field') { const opp = owner.id === 'player' ? this.cpu : this.player; if(opp.units.filter(u=>u).length < 3) return false; }
            UI.log(`ç½ :${r.data.name}`); this.resolveEffect(r, owner, targetUnit); owner.reacts[idx] = null; return true;
        },
        updateStats() { [this.player, this.cpu].forEach(p => { const hasAura = p.units.some(u => u && u.data.passive === 'aura_atk_1'); p.units.forEach(u => { if(u) u.passiveAtk = hasAura ? 1 : 0; }); }); },
        damageUnit(u, amt) { if(u.data.passive === 'spell_resist') amt = Math.max(0, amt - 1); if(u.destructionImmune) { UI.log("ç„¡åŠ¹"); return; } u.damageTaken += amt; UI.floatText(u, `-${amt}`, '#ff4444'); if(u.def <= 0) this.destroyUnit(u); },
        damagePlayer(p, amt) { p.lp -= amt; UI.floatText(p.id==='player'?'player-lp':'cpu-lp', `-${amt}`, '#ff4444'); UI.update(); if(p.lp <= 0) this.endGame(p.id==='player'?'cpu':'player'); },
        destroyUnit(u) { if(u.destructionImmune){ UI.log("ç„¡åŠ¹"); return; } const o = u.owner === 'player' ? this.player : this.cpu; const i = o.units.indexOf(u); if(i !== -1) { o.units[i] = null; UI.floatText(u, "DIE", '#888'); } },
        bounceUnit(u) { const o = u.owner === 'player' ? this.player : this.cpu; const i = o.units.indexOf(u); if(i !== -1) { o.units[i] = null; o.hand.push(new Card(u.id, u.owner)); UI.log("ãƒã‚¦ãƒ³ã‚¹"); } },
        findBestTarget(units, criteria) { const v = units.filter(u=>u); if(v.length===0) return null; if(criteria==='ATK') return v.sort((a,b)=>b.atk-a.atk)[0]; return v.sort((a,b)=>b.def-a.def)[0]; },
        endGame(winner) { this.gameOver = true; document.getElementById('result-screen').classList.remove('hidden'); document.getElementById('result-msg').innerText = winner === 'player' ? "YOU WIN!" : "YOU LOSE"; }
    };

    const UI = {
        update() {
            document.getElementById('player-lp').innerText=Game.player.lp; document.getElementById('cpu-lp').innerText=Game.cpu.lp;
            document.getElementById('phase-badge').innerText=Game.phase;
            const ph=document.getElementById('player-hand'); ph.innerHTML='';
            Game.player.hand.forEach((c,i)=>{
                const e=this.createCard(c); e.classList.add('hand-card');
                e.onclick=()=>{
                    if(Game.turn!=='player'||Game.phase!==PHASE.MAIN)return;
                    if(Game.selectedCard===c){ if(c.data.target===TARGET.NONE&&c.data.type===TYPE.SPELL){Game.playCard(Game.player,i);Game.selectedCard=null;}else Game.selectedCard=null; }
                    else Game.selectedCard=c; this.showDetail(c); this.update();
                };
                if(Game.selectedCard===c)e.classList.add('selected'); ph.appendChild(e);
            });
            this.renderField('cpu-units',Game.cpu.units,'cpu',0); this.renderField('cpu-reacts',Game.cpu.reacts,'cpu',1);
            this.renderField('player-units',Game.player.units,'player',0); this.renderField('player-reacts',Game.player.reacts,'player',1);
            const b=document.getElementById('btn-next');
            if(Game.phase===PHASE.MAIN){b.innerText="To Battle";b.disabled=Game.turn!=='player';}
            else if(Game.phase===PHASE.BATTLE){b.innerText="End Turn";b.disabled=Game.turn!=='player';}
            else{b.innerText="Wait";b.disabled=true;}
        },
        renderField(id,list,owner,isReact){
            const d=document.getElementById(id); const slots=d.querySelectorAll('.slot');
            slots.forEach((sl,i)=>{
                sl.innerHTML=''; sl.className=isReact?'slot reaction':'slot'; sl.onclick=null;
                const u=list[i];
                if(u){
                    const e=this.createCard(u);
                    e.onclick=(ev)=>{ ev.stopPropagation(); this.showDetail(u); if(owner==='player'&&Game.phase===PHASE.BATTLE&&!isReact&&u.canAttack&&!u.hasAttacked){Game.selectedUnit=u;this.update();UI.log("æ”»æ’ƒç›®æ¨™ã‚’é¸æŠ");} };
                    if(owner==='cpu'&&isReact)e.classList.add('face-down');
                    if(u.hasAttacked||u.isLocked)e.classList.add('exhausted');
                    if(u.destructionImmune)e.style.boxShadow="0 0 5px #5c97f7";
                    if(Game.selectedUnit===u)e.classList.add('selected');
                    sl.appendChild(e);
                }
                if(Game.turn==='player'){
                    if(Game.phase===PHASE.MAIN&&Game.selectedCard){
                        const c=Game.selectedCard; const hi=Game.player.hand.indexOf(c);
                        if(owner==='player'&&!isReact&&!u&&c.data.type===TYPE.UNIT&&Game.player.summonCount<2&&!Game.player.units.some(k=>k&&k.data.name===c.data.name)){sl.classList.add('valid');sl.onclick=()=>{Game.playCard(Game.player,hi,null,i);Game.selectedCard=null;};}
                        if(owner==='player'&&isReact&&!u&&c.data.type===TYPE.REACT){sl.classList.add('valid');sl.onclick=()=>{Game.playCard(Game.player,hi,null,i);Game.selectedCard=null;};}
                        if(((owner==='player'&&c.data.target===TARGET.ALLY)||(owner==='cpu'&&c.data.target===TARGET.ENEMY))&&!isReact&&u){sl.classList.add('valid');sl.onclick=()=>{Game.playCard(Game.player,hi,u);Game.selectedCard=null;};}
                    }
                    if(Game.phase===PHASE.BATTLE&&owner==='cpu'&&!isReact&&u&&Game.selectedUnit){
                        sl.classList.add('attack-target');sl.onclick=()=>{Game.attack(Game.selectedUnit,i);Game.selectedUnit=null;};
                    }
                }
            });
            if(owner==='cpu'&&!isReact&&Game.phase===PHASE.BATTLE&&Game.selectedUnit&&!list.some(u=>u)){ d.style.cursor='crosshair';d.onclick=(e)=>{if(e.target===d){Game.attack(Game.selectedUnit,-1);Game.selectedUnit=null;}}; }
        },
        createCard(c){
            const e=document.createElement('div');e.className=`card ${c.data.type.toLowerCase()}`;
            e.innerHTML=`<div class="card-name">${c.data.name}</div><div class="card-art">${c.data.icon}</div><div class="card-stats">${c.data.type===TYPE.UNIT?`<span class="val-atk">âš”${c.atk}</span><span class="val-def">ğŸ›¡${c.def}</span>`:''}</div>`;
            return e;
        },
        showDetail(c){
            const v=document.getElementById('card-detail-view');
            v.innerHTML=`
                <div class="detail-name">${c.data.name}</div>
                <div class="detail-icon">${c.data.icon}</div>
                ${c.data.type===TYPE.UNIT?`<div class="detail-stats"><span class="val-atk">âš”${c.atk}</span> <span class="val-def">ğŸ›¡${c.def}</span></div>`:''}
                <div class="detail-text">${c.data.desc}</div>
            `;
        },
        log(m){ const d=document.createElement('div');d.className='log-line';d.innerText=m;document.getElementById('log-panel').appendChild(d); document.getElementById('log-panel').scrollTop = document.getElementById('log-panel').scrollHeight;},
        floatText(t,txt,c){
            const el=document.createElement('div');el.className='float-txt';el.innerText=txt;el.style.color=c;
            let p=null;
            if(t==='player-lp')p=document.querySelector('.player-lp');
            else if(t==='cpu-lp')p=document.querySelector('.enemy-lp');
            else if(t.uid){ const s=document.querySelectorAll('.slot'); s.forEach(sl=>{if(sl.firstChild&&sl.firstChild.innerText.includes(t.data.name))p=sl;});}
            if(p)p.appendChild(el);setTimeout(()=>el.remove(),1200);
        }
    };
</script>
</body>
</html>
