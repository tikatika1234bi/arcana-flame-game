<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Arcana Flame - Online & Gacha</title>
    <style>
        /* --- „Éô„Éº„Çπ„Çπ„Çø„Ç§„É´ --- */
        :root { --bg-color: #121212; --panel-bg: #1e1e1e; --text-color: #e0e0e0; --accent-blue: #5c97f7; --accent-red: #f75c5c; --highlight: #ffd700; }
        body { margin: 0; background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        #app { display: flex; flex-direction: column; height: 100vh; max-width: 900px; margin: 0 auto; background: #000; border-left: 1px solid #333; border-right: 1px solid #333; }
        .hidden { display: none !important; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        button { cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: 0.2s; }
        
        /* --- UI„Çπ„Çø„Ç§„É´ --- */
        .gacha-btn { padding: 15px 40px; font-size: 18px; background: linear-gradient(45deg, #f1c40f, #e67e22); color: #000; margin: 10px; box-shadow: 0 0 15px rgba(241, 196, 15, 0.5); }
        .gacha-btn:hover { transform: scale(1.05); }
        .gacha-btn:disabled { filter: grayscale(1); cursor: not-allowed; transform: none; box-shadow: none; }
        .menu-btn { padding: 10px 20px; background: #444; color: #fff; margin: 5px; min-width: 150px;}
        .logout-btn { padding: 5px 10px; background: #555; color: #aaa; font-size: 10px; margin-top: 5px; }
        .stone-display { font-size: 20px; color: var(--highlight); margin: 10px; border: 1px solid #444; padding: 5px 20px; border-radius: 20px; background: #222; }
        .user-info { position: absolute; top: 10px; right: 10px; font-size: 12px; color: #888; z-index: 300; text-align: right;}
        .gacha-result { display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap; justify-content: center; min-height: 120px; }

        /* --- „Ç≤„Éº„É†ÂÜÖ„Çπ„Çø„Ç§„É´ --- */
        .field-section { flex: 1; display: flex; flex-direction: column; justify-content: center; position: relative; padding: 5px; }
        .enemy-area { background: rgba(100, 30, 30, 0.2); border-bottom: 2px solid #333; }
        .player-area { background: rgba(30, 60, 100, 0.2); }
        .row { display: flex; justify-content: center; gap: 10px; min-height: 120px; align-items: center; }
        .hand-container { height: 130px; background: #0a0a0a; display: flex; justify-content: center; align-items: center; gap: 5px; overflow-x: auto; }
        .slot { width: 80px; height: 110px; border: 2px dashed #444; border-radius: 6px; position: relative; transition: 0.2s; }
        .slot.valid { background: rgba(255, 215, 0, 0.2); border-color: var(--highlight); cursor: pointer; animation: pulse 1.5s infinite; }
        .slot.attack-target { background: rgba(255, 50, 50, 0.3); border-color: var(--accent-red); cursor: crosshair; }
        
        .card { width: 100%; height: 100%; background: var(--panel-bg); border: 2px solid #555; border-radius: 5px; display: flex; flex-direction: column; padding: 2px; font-size: 9px; cursor: pointer; position: relative; }
        .card.unit { border-top: 4px solid #a3b1b5; }
        .card.spell { border-top: 4px solid #b580d1; }
        .card.reaction { border-top: 4px solid #e08e45; }
        .card.face-down { background: repeating-linear-gradient(135deg, #222, #222 10px, #333 10px, #333 20px); border-color: #444; }
        .card.face-down * { display: none; }
        .card.exhausted { filter: grayscale(0.8) brightness(0.7); }
        .card.selected { border-color: var(--highlight); transform: translateY(-10px); box-shadow: 0 0 10px var(--highlight); }
        
        .card-name { font-weight: bold; text-align: center; white-space: nowrap; overflow: hidden; margin-bottom: 2px; }
        .card-art { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 24px; background: rgba(0,0,0,0.3); }
        .card-stats { display: flex; justify-content: space-between; font-weight: bold; font-size: 11px; padding: 0 2px; margin-top: auto;}
        .val-atk { color: #ff7777; } .val-def { color: #77aaff; }
        
        .center-hud { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; pointer-events: none; text-align: center;}
        #phase-badge { background: var(--accent-blue); color: #fff; padding: 5px 20px; border-radius: 15px; font-weight: bold; font-size: 18px; margin-bottom: 10px; }
        #btn-next { pointer-events: auto; background: #eee; color: #111; padding: 8px 25px; font-size: 14px; }
        #log-panel { position: absolute; bottom: 140px; right: 10px; width: 200px; height: 100px; background: rgba(0,0,0,0.8); border: 1px solid #444; overflow-y: auto; pointer-events: none; z-index: 50; font-size: 10px; color: #ccc; display: flex; flex-direction: column-reverse;}
        .log-line { border-bottom: 1px solid #333; margin-bottom: 2px; }
        .float-txt { position: absolute; font-weight: bold; font-size: 18px; animation: floatUp 1.2s forwards; z-index: 150; pointer-events: none; text-shadow: 1px 1px 0 #000; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        @keyframes floatUp { 0% { transform:translateY(0) scale(1); opacity:1; } 100% { transform:translateY(-50px) scale(1.5); opacity:0; } }
    </style>
</head>
<body>

<!-- „É¶„Éº„Ç∂„ÉºÊÉÖÂ†± -->
<div class="user-info">
    <span id="user-name">Guest</span><br>
    üíé <span id="user-stones">0</span>
</div>

<!-- 1. „É≠„Ç∞„Ç§„É≥ÁîªÈù¢ -->
<div id="login-screen" class="overlay">
    <h1 style="color:var(--highlight)">ARCANA FLAME</h1>
    <p>Online Battle & Gacha</p>
    <button class="gacha-btn" onclick="Auth.login()">Google„Åß„É≠„Ç∞„Ç§„É≥</button>
</div>

<!-- 2. „É°„Éã„É•„ÉºÔºÜ„Ç¨„ÉÅ„É£ÁîªÈù¢ -->
<div id="menu-screen" class="overlay hidden">
    <h2>MAIN MENU</h2>
    <div class="stone-display">ÊâÄÊåÅÈ≠îÊ≥ïÁü≥: <span id="menu-stones">0</span></div>
    
    <div style="border:1px solid #444; padding:20px; border-radius:10px; background:#222; margin-bottom:20px; width: 300px; text-align:center;">
        <h3>üîÆ „Ç´„Éº„Éâ„Éë„ÉÉ„ÇØ„Ç¨„ÉÅ„É£</h3>
        <p style="font-size:12px; color:#aaa;">1Âõû 100Áü≥ / ÂÖ®26Á®Æ</p>
        <button class="gacha-btn" onclick="Gacha.pull()">„Ç¨„ÉÅ„É£„ÇíÂºï„Åè (100üíé)</button>
        <button id="bonus-btn" class="menu-btn" onclick="Gacha.addFreeStones()">„É≠„Ç∞„Ç§„É≥„Éú„Éº„Éä„Çπ (+500üíé)</button>
        <div class="gacha-result" id="gacha-result"></div>
    </div>

    <div style="margin-top:10px;">
        <h3>‚öîÔ∏è „Éá„ÉÉ„Ç≠ÈÅ∏Êäû„Åó„Å¶„Éê„Éà„É´</h3>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button class="menu-btn" onclick="Game.start(0)">ÁÉàÁÅ´„ÅÆ„Éâ„É©„Ç¥„É≥</button>
            <button class="menu-btn" onclick="Game.start(1)">ÊäÄÂ∑ß„ÅÆÈ≠îË°ìÂ∏´</button>
            <button class="menu-btn" onclick="Game.start(2)">ÈâÑÂ£Å„ÅÆ„Éì„Éº„Çπ„Éà</button>
        </div>
    </div>
    
    <button class="logout-btn" onclick="Auth.logout()">„É≠„Ç∞„Ç¢„Ç¶„Éà</button>
</div>

<!-- 3. „Ç≤„Éº„É†ÁîªÈù¢ -->
<div id="game-app" class="hidden">
    <div class="field-section enemy-area">
        <div style="position:absolute; top:5px; left:5px; font-size:12px;">CPU LP: <span id="cpu-lp">12</span></div>
        <div class="row" id="cpu-units"><div class="slot" data-i="0"></div><div class="slot" data-i="1"></div><div class="slot" data-i="2"></div></div>
        <div class="row" id="cpu-reacts" style="min-height:80px;"><div class="slot reaction" data-i="0"></div><div class="slot reaction" data-i="1"></div></div>
    </div>
    <div class="center-hud">
        <div id="phase-badge">START</div>
        <button id="btn-next" onclick="Game.nextPhase()">Start</button>
    </div>
    <div class="field-section player-area">
        <div class="row" id="player-reacts" style="min-height:80px;"><div class="slot reaction" data-i="0"></div><div class="slot reaction" data-i="1"></div></div>
        <div class="row" id="player-units"><div class="slot" data-i="0"></div><div class="slot" data-i="1"></div><div class="slot" data-i="2"></div></div>
        <div style="position:absolute; bottom:5px; left:5px; font-size:12px;">
            YOU LP: <span id="player-lp">12</span> | Summon: <span id="summon-cnt">0</span>/2
        </div>
    </div>
    <div class="hand-container" id="player-hand"></div>
    <div id="log-panel"></div>
    <button class="menu-btn" style="position:absolute; top:5px; right:5px; z-index:300; min-width:80px;" onclick="location.reload()">RETIRE</button>
    
    <!-- „É™„Ç∂„É´„ÉàÁîªÈù¢ -->
    <div id="result-screen" class="overlay hidden">
        <h1 id="result-msg" style="font-size:48px;"></h1>
        <button class="menu-btn" onclick="location.reload()">TITLE SCREEN</button>
    </div>
</div>

<!-- „É°„Ç§„É≥„Çπ„ÇØ„É™„Éó„Éà -->
<script type="module">
    // ----------------------------------------------------------------
    // 1. Firebase Setup
    // ----------------------------------------------------------------
    // Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyCNgyBeSzbc74e6iWNnY0irswl24ciAfcg",
  authDomain: "arcana-flame-game.firebaseapp.com",
  projectId: "arcana-flame-game",
  storageBucket: "arcana-flame-game.firebasestorage.app",
  messagingSenderId: "562804440230",
  appId: "1:562804440230:web:26f7bd08ea47d39ad80867",
  measurementId: "G-XT2EDR06R1"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);

    // ----------------------------------------------------------------
    // 2. Data & Constants
    // ----------------------------------------------------------------
    const TYPE = { UNIT: 'UNIT', SPELL: 'SPELL', REACT: 'REACT' };
    const TARGET = { NONE: 'NONE', ENEMY: 'ENEMY', ALLY: 'ALLY', ANY: 'ANY' };
    const PHASE = { DRAW: 'DRAW', MAIN: 'MAIN', BATTLE: 'BATTLE', END: 'END' };

    const DB = {
        'd01': { name: '„Éï„É¨„Ç§„É†„Éª„Éâ„É©„Ç¥„É≥', type: TYPE.UNIT, atk: 3, def: 3, icon: 'üê≤', desc: '-', target: TARGET.NONE },
        'd02': { name: '„Éú„É´„Ç´„Éã„ÉÉ„ÇØ„Éª„ÉØ„Ç§„Éê„Éº„É≥', type: TYPE.UNIT, atk: 4, def: 2, icon: 'ü¶ñ', desc: '-', target: TARGET.NONE },
        'd03': { name: '„Ç¨„Éº„Éâ„Çπ„Ç±„Ç§„É´„Éª„Éâ„É©„Ç¥„É≥', type: TYPE.UNIT, atk: 2, def: 5, icon: 'üõ°Ô∏è', desc: '-', target: TARGET.NONE },
        'd04': { name: '„É´„Éì„Éº„Éõ„Éº„É≥„Éª„Éâ„É©„Ç¥„É≥', type: TYPE.UNIT, atk: 3, def: 4, icon: 'üêÇ', desc: '-', target: TARGET.NONE },
        'd05': { name: '„ÇΩ„Éº„É©„Éº„Éñ„É¨„Ç§„Ç∫', type: TYPE.UNIT, atk: 5, def: 3, icon: 'üåû', desc: 'Âè¨Âñö:Êïµ2„ÉÄ„É°', effect: 'dmg_2', target: TARGET.NONE },
        's01': { name: '„Éâ„É©„Ç¥„É≥„Éª„Éï„Ç©„Éº„Çπ', type: TYPE.SPELL, icon: 'üí™', desc: 'Âë≥ÊñπATK+2(T)', effect: 'buff_atk_2_turn', target: TARGET.ALLY },
        's02': { name: '„Éï„É¨„Ç§„É†„Éê„Éº„Çπ„Éà', type: TYPE.SPELL, icon: 'üî•', desc: 'Êïµ3„ÉÄ„É°', effect: 'dmg_3', target: TARGET.ENEMY },
        's03': { name: 'ÁÜ±È¢®„ÅÆÂè∑‰ª§', type: TYPE.SPELL, icon: 'üå¨Ô∏è', desc: 'ÂÖ®Âë≥ÊñπATK+1(T)', effect: 'all_atk_1_turn', target: TARGET.NONE },
        'r01': { name: '„Éâ„É©„Ç¥„É≥„ÅÆÂíÜÂìÆ', type: TYPE.REACT, icon: 'üì¢', desc: 'Ë¢´Âºæ:ATK+1(T)', trigger: 'attacked', effect: 'react_atk_1' },
        'm01': { name: '„Ç¢„Éº„ÇØ„Éª„Ç¢„Éó„É¨„É≥„ÉÜ„Ç£„Çπ', type: TYPE.UNIT, atk: 2, def: 2, icon: 'üßô', desc: 'Âè¨Âñö:Âë≥ÊñπDEF+1', effect: 'buff_def_1', target: TARGET.NONE },
        'm02': { name: '„ÇØ„É≠„Éé„Éû„É≥„Çµ„Éº', type: TYPE.UNIT, atk: 1, def: 3, icon: '‚è≥', desc: 'Ê∞∏Á∂ö:È≠îËªΩÊ∏õ1', passive: 'spell_resist', target: TARGET.NONE },
        'm03': { name: '„É´„Éº„É≥„Éª„Ç®„É≥„ÉÅ„É£„É≥„Çø„Éº', type: TYPE.UNIT, atk: 2, def: 3, icon: '‚ú®', desc: 'Ê∞∏Á∂ö:Âë≥ÊñπATK+1', passive: 'aura_atk_1', target: TARGET.NONE },
        'm04': { name: '„Éû„ÇÆ„Ç¢„Éª„Çπ„Éà„É©„ÉÜ„Ç∏„Çπ„Éà', type: TYPE.UNIT, atk: 3, def: 2, icon: 'üìñ', desc: 'Âè¨Âñö:1„Éâ„É≠„Éº', effect: 'draw_1', target: TARGET.NONE },
        'm05': { name: 'Â§ßË≥¢ËÄÖ„Ç™„É´„Éá„Ç£„É≥', type: TYPE.UNIT, atk: 4, def: 4, icon: 'üë¥', desc: 'Âè¨Âñö:ÊïµDEF-2', effect: 'debuff_def_2', target: TARGET.NONE },
        's11': { name: 'Â∞ÅÂç∞„ÅÆÈñÉÂÖâ', type: TYPE.SPELL, icon: 'üîí', desc: 'ÊïµÊîªÊíÉ‰∏çÂèØ(T)', effect: 'lock', target: TARGET.ENEMY },
        's12': { name: '„Éá„Ç£„Çπ„Ç∏„É£„É≥„ÇØ„Ç∑„Éß„É≥', type: TYPE.SPELL, icon: 'üö´', desc: 'ÊïµATK0(T)', effect: 'zero_atk', target: TARGET.ENEMY },
        's13': { name: 'È≠îÂ∞éËß£Êûê', type: TYPE.SPELL, icon: 'üìö', desc: '2„Éâ„É≠„Éº', effect: 'draw_2', target: TARGET.NONE },
        's14': { name: '„Éû„Éä„Ç∑„Éº„É´„Éâ', type: TYPE.SPELL, icon: 'üõ°Ô∏è', desc: 'Âë≥ÊñπÁ†¥Â£äÁÑ°Âäπ(T)', effect: 'shield', target: TARGET.ALLY },
        'r11': { name: 'ÂèçËª¢„ÅÆÁµêÁïå', type: TYPE.REACT, icon: 'üõë', desc: 'È≠îÊ≥ïÁÑ°ÂäπÂåñ', trigger: 'spell', effect: 'negate' },
        'r12': { name: '„Ç¢„Çπ„Éà„É©„É´„Çµ„Ç§„ÇØ„É´', type: TYPE.REACT, icon: 'üåå', desc: 'Êïµ3‰Ωì:2‰ΩìÊàª„Åô', trigger: 'full_field', effect: 'bounce_2' },
        'b01': { name: '„Ç∑„Éº„É´„Éâ„Éô„Ç¢', type: TYPE.UNIT, atk: 2, def: 5, icon: 'üêª', desc: '-', target: TARGET.NONE },
        'b02': { name: '„Ç¢„Ç§„Ç¢„É≥„Éï„Ç°„É≥„Ç∞', type: TYPE.UNIT, atk: 3, def: 4, icon: 'üê∫', desc: '-', target: TARGET.NONE },
        'b03': { name: '„É™„Éö„Ç¢„Éõ„Éº„É≥', type: TYPE.UNIT, atk: 1, def: 4, icon: 'ü¶Ñ', desc: 'Âè¨Âñö:Âë≥ÊñπDEF+2', effect: 'buff_def_2', target: TARGET.NONE },
        'b04': { name: '„É≠„ÉÉ„ÇØ„Ç∏„É£„Ç¶', type: TYPE.UNIT, atk: 3, def: 6, icon: 'üóø', desc: '-', target: TARGET.NONE },
        'b05': { name: '„Çø„Ç§„Çø„É≥', type: TYPE.UNIT, atk: 4, def: 7, icon: 'üëπ', desc: 'ÂèçÊíÉ2„ÉÄ„É°', passive: 'reflect', target: TARGET.NONE },
        's21': { name: '„Éï„Ç©„Éº„Éà„É¨„Çπ', type: TYPE.SPELL, icon: 'üè∞', desc: 'Âë≥ÊñπDEF+3', effect: 'buff_def_3', target: TARGET.ALLY },
        's22': { name: '„Ç¢„Ç§„Ç¢„É≥„Çπ„Éû„ÉÉ„Ç∑„É•', type: TYPE.SPELL, icon: 'üî®', desc: 'Êïµ2or4„ÉÄ„É°', effect: 'cond_dmg', target: TARGET.ENEMY },
        's23': { name: '„Éê„É™„Ç¢„Éï„Ç£„Éº„É´„Éâ', type: TYPE.SPELL, icon: 'üåê', desc: 'ÂÖ®Âë≥ÊñπDEF+1(T)', effect: 'all_def_1_turn', target: TARGET.NONE },
        'r21': { name: 'Â†ÖÁâ¢„Å™„ÇãÂèçÊíÉ', type: TYPE.REACT, icon: '‚öîÔ∏è', desc: 'Ë¢´Âºæ:Êïµ2„ÉÄ„É°', trigger: 'attacked', effect: 'react_dmg_2' }
    };

    const DECK_LISTS = [
        ['d01','d01','d01', 'd02','d02','d02', 'd03','d03', 'd04','d04', 'd05','d05', 's01','s01', 's02','s02', 's03','s03', 'r01','r01'],
        ['m01','m01','m01', 'm02','m02', 'm03','m03','m03', 'm04','m04', 'm05','m05', 's11','s11', 's12','s12', 's13', 's14', 'r11', 'r12'],
        ['b01','b01','b01', 'b02','b02','b02', 'b03','b03', 'b04','b04', 'b05','b05', 's21','s21', 's22','s22', 's23','s23', 'r21','r21']
    ];

    // ----------------------------------------------------------------
    // 3. Auth & Gacha System
    // ----------------------------------------------------------------
    window.Auth = {
        user: null,
        async login() {
            try { await signInWithPopup(auth, provider); } 
            catch (e) { alert("„É≠„Ç∞„Ç§„É≥„Ç®„É©„Éº: " + e.message); }
        },
        async logout() {
            try { 
                await signOut(auth); 
                location.reload(); 
            } catch (e) { alert("„É≠„Ç∞„Ç¢„Ç¶„Éà„Ç®„É©„Éº: " + e.message); }
        }
    };

    onAuthStateChanged(auth, async (user) => {
        if (user) {
            window.Auth.user = user;
            document.getElementById('user-name').innerText = user.displayName;
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('menu-screen').classList.remove('hidden');
            await Gacha.loadUserData(user.uid);
        }
    });

    window.Gacha = {
        stones: 0,
        collection: [],
        lastBonusDate: null,

        async loadUserData(uid) {
            try {
                const userRef = doc(db, "users", uid);
                const docSnap = await getDoc(userRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    this.stones = data.stones || 0;
                    this.collection = data.collection || [];
                    this.lastBonusDate = data.lastBonusDate || null;
                } else {
                    this.stones = 3000;
                    this.collection = [];
                    await setDoc(userRef, { stones: 3000, collection: [], lastBonusDate: null });
                }
                this.updateDisplay();
                this.checkBonusButton();
            } catch (e) { console.error(e); }
        },

        updateDisplay() {
            document.getElementById('user-stones').innerText = this.stones;
            document.getElementById('menu-stones').innerText = this.stones;
        },

        checkBonusButton() {
            const today = new Date().toDateString();
            const btn = document.getElementById('bonus-btn');
            if (this.lastBonusDate === today) {
                btn.disabled = true;
                btn.innerText = "ÂèóÂèñÊ∏à„Åø";
            } else {
                btn.disabled = false;
                btn.innerText = "„É≠„Ç∞„Ç§„É≥„Éú„Éº„Éä„Çπ (+500üíé)";
            }
        },

        async addFreeStones() {
            if(!window.Auth.user) return;
            const today = new Date().toDateString();
            
            if (this.lastBonusDate === today) {
                alert("Êú¨Êó•„ÅÆ„Éú„Éº„Éä„Çπ„ÅØÊó¢„Å´Âèó„ÅëÂèñ„Å£„Å¶„ÅÑ„Åæ„ÅôÔºÅ");
                return;
            }

            this.stones += 500;
            this.lastBonusDate = today;
            this.updateDisplay();
            this.checkBonusButton();
            
            const userRef = doc(db, "users", window.Auth.user.uid);
            await updateDoc(userRef, {
                stones: increment(500),
                lastBonusDate: today
            });
            alert("„É≠„Ç∞„Ç§„É≥„Éú„Éº„Éä„Çπ 500ÂÄã„ÇíÂèó„ÅëÂèñ„Çä„Åæ„Åó„ÅüÔºÅ");
        },

        async pull() {
            if (this.stones < 100) return alert("Áü≥„ÅåË∂≥„Çä„Åæ„Åõ„ÇìÔºÅ");
            this.stones -= 100;
            this.updateDisplay();

            const keys = Object.keys(DB);
            const hitId = keys[Math.floor(Math.random() * keys.length)];
            const d = DB[hitId];
            this.collection.push(hitId);

            const userRef = doc(db, "users", window.Auth.user.uid);
            await updateDoc(userRef, { stones: increment(-100), collection: arrayUnion(hitId) });

            document.getElementById('gacha-result').innerHTML = `
                <div style="text-align:center; animation:pulse 0.5s;">
                    <div style="color:#888; font-size:10px;">GET!</div>
                    <div class="card ${d.type==='UNIT'?'unit':(d.type==='SPELL'?'spell':'reaction')}" style="width:80px; height:110px;">
                        <div class="card-name">${d.name}</div><div class="card-art">${d.icon}</div>
                        <div class="card-stats">${d.type==='UNIT'?`<span class="val-atk">‚öî${d.atk}</span><span class="val-def">üõ°${d.def}</span>`:''}</div>
                    </div>
                </div>`;
        }
    };

    // ----------------------------------------------------------------
    // 4. Game Logic
    // ----------------------------------------------------------------
    class Card {
        constructor(id, owner) {
            this.id = id; this.data = DB[id]; this.owner = owner;
            this.uid = Math.random().toString(36).substr(2, 9);
            this.baseAtk = this.data.atk || 0; this.baseDef = this.data.def || 0;
            this.atkModPermanent = 0; this.atkModTurn = 0; this.defModPermanent = 0; this.defModTurn = 0; this.damageTaken = 0;
            this.canAttack = true; this.hasAttacked = false; this.isLocked = false; this.destructionImmune = false;
        }
        get atk() { return Math.max(0, this.baseAtk + this.atkModPermanent + this.atkModTurn + (this.passiveAtk || 0)); }
        get def() { return (this.baseDef + this.defModPermanent + this.defModTurn) - this.damageTaken; }
        resetTurn() { this.hasAttacked = false; this.canAttack = !this.isLocked; this.isLocked = false; this.destructionImmune = false; this.atkModTurn = 0; this.defModTurn = 0; }
    }

    const AI = {
        act() {
            if(window.Game.turn !== 'cpu') return;
            const cpu = window.Game.cpu;
            const opp = window.Game.player;

            // Summon
            const units = cpu.hand.map((c,i)=>({c,i})).filter(o=>o.c.data.type === TYPE.UNIT);
            const playableUnits = units.filter(o => !cpu.units.some(u => u && u.data.name === o.c.data.name));
            if(playableUnits.length > 0 && cpu.summonCount < 2) {
                playableUnits.sort((a,b) => (b.c.atk+b.c.def) - (a.c.atk+a.c.def));
                const slot = cpu.units.findIndex(u=>u===null);
                if(slot !== -1) {
                    window.Game.playCard(cpu, playableUnits[0].i, null, slot);
                    setTimeout(()=>this.act(), 600);
                    return;
                }
            }

            // Spells
            const spells = cpu.hand.map((c,i)=>({c,i})).filter(o=>o.c.data.type !== TYPE.UNIT);
            if(spells.length > 0) {
                const s = spells[0];
                if(s.c.data.type === TYPE.REACT) {
                    const slot = cpu.reacts.findIndex(r=>r===null);
                    if(slot !== -1) window.Game.playCard(cpu, s.i, null, slot);
                } else {
                    let target = null;
                    if(s.c.data.target === TARGET.ENEMY) target = window.Game.findBestTarget(opp.units, 'ATK');
                    if(s.c.data.target === TARGET.ALLY) target = window.Game.findBestTarget(cpu.units, 'ATK');
                    if(s.c.data.target === TARGET.NONE || target) {
                        window.Game.playCard(cpu, s.i, target);
                    }
                }
            }
            setTimeout(()=>window.Game.nextPhase(), 1000);
        },
        battle() {
            if(window.Game.turn !== 'cpu') return;
            const attackers = window.Game.cpu.units.filter(u=>u && u.canAttack && !u.hasAttacked);
            if(attackers.length === 0) { setTimeout(()=>window.Game.nextPhase(), 500); return; }

            attackers.sort((a,b)=>b.atk - a.atk);
            const att = attackers[0];
            const enemies = window.Game.player.units.map((u,i)=>({u,i})).filter(o=>o.u);
            let targetIdx = -2; 

            if(enemies.length === 0) targetIdx = -1;
            else {
                const kills = enemies.filter(e => att.atk > e.u.def);
                if(kills.length > 0) {
                    kills.sort((a,b)=>b.u.atk - a.u.atk);
                    targetIdx = kills[0].i;
                } else {
                    const trades = enemies.filter(e => att.atk === e.u.def && e.u.atk >= att.atk);
                    if(trades.length > 0) targetIdx = trades[0].i;
                }
            }

            if(targetIdx !== -2) window.Game.attack(att, targetIdx);
            else att.hasAttacked = true;

            setTimeout(()=>this.battle(), 1000);
        }
    };

    window.Game = {
        player: null, cpu: null, turn: 'player', phase: PHASE.DRAW, selectedCard: null, selectedUnit: null, gameOver: false, firstTurn: true,

        start(deckIdx) {
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-app').classList.remove('hidden');
            
            const createPlayer = (id, dIdx) => ({ id, lp: 12, deck: this.shuffle(DECK_LISTS[dIdx].map(cid => new Card(cid, id))), hand: [], units: [null, null, null], reacts: [null, null], summonCount: 0 });
            this.player = createPlayer('player', deckIdx);
            let cpuDeckIdx = (deckIdx + 1 + Math.floor(Math.random()*2)) % 3;
            this.cpu = createPlayer('cpu', cpuDeckIdx);

            for(let i=0; i<4; i++) { this.draw(this.player); this.draw(this.cpu); }
            this.turn = Math.random() < 0.5 ? 'player' : 'cpu';
            UI.log(`Game Start! ÂÖàÊîª: ${this.turn.toUpperCase()}`);
            this.startTurn();
        },
        shuffle(arr) { for(let i=arr.length-1; i>0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; },
        draw(p, amt=1) { for(let i=0; i<amt; i++) { if(p.deck.length > 0) p.hand.push(p.deck.pop()); else this.endGame(p.id === 'player' ? 'cpu' : 'player'); } },
        startTurn() {
            this.phase = PHASE.DRAW;
            const p = this.turn === 'player' ? this.player : this.cpu;
            p.summonCount = 0;
            [this.player, this.cpu].forEach(pl => pl.units.forEach(u => { if(u) u.resetTurn(); }));
            this.updateStats(); UI.update();
            setTimeout(() => {
                if(this.firstTurn) { this.firstTurn = false; UI.log("ÂÖàÊîª1T:„Éâ„É≠„Éº„Çπ„Ç≠„ÉÉ„Éó"); } else { this.draw(p); }
                this.phase = PHASE.MAIN; UI.update();
                if(this.turn === 'cpu') AI.act();
            }, 800);
        },
        nextPhase() {
            if(this.gameOver) return;
            if(this.phase === PHASE.MAIN) { this.phase = PHASE.BATTLE; UI.update(); if(this.turn === 'cpu') AI.battle(); }
            else if(this.phase === PHASE.BATTLE) { this.phase = PHASE.END; this.turn = this.turn === 'player' ? 'cpu' : 'player'; this.startTurn(); }
        },
        playCard(p, handIdx, targetUnit=null, slotIdx=null) {
            const card = p.hand[handIdx]; if(!card) return;
            if(card.data.type === TYPE.UNIT) {
                if(p.summonCount >= 2) { UI.log("Âè¨ÂñöÊ®©„Å™„Åó"); return; }
                if(p.units[slotIdx] !== null || p.units.some(u => u && u.data.name === card.data.name)) { UI.log("Âè¨Âñö‰∏çÂèØ"); return; }
            }
            const opp = p.id === 'player' ? this.cpu : this.player;
            if(card.data.type === TYPE.SPELL && this.checkReaction('spell', opp, null)) { p.hand.splice(handIdx, 1); UI.log("ÁÑ°ÂäπÂåñ"); UI.update(); return; }
            p.hand.splice(handIdx, 1);
            if(card.data.type === TYPE.UNIT) { p.units[slotIdx] = card; p.summonCount++; UI.log(`Âè¨Âñö:${card.data.name}`); this.resolveEffect(card, p, null); this.checkReaction('full_field', opp, null); }
            else if(card.data.type === TYPE.SPELL) { UI.log(`Áô∫Âãï:${card.data.name}`); this.resolveEffect(card, p, targetUnit); }
            else if(card.data.type === TYPE.REACT) { p.reacts[slotIdx] = card; UI.log(`„Çª„ÉÉ„Éà:${card.data.name}`); }
            this.updateStats(); UI.update();
        },
        attack(attacker, targetIdx) {
            if(!attacker.canAttack || attacker.hasAttacked) return;
            attacker.hasAttacked = true;
            const defOwner = attacker.owner === 'player' ? this.cpu : this.player;
            const defender = targetIdx === -1 ? null : defOwner.units[targetIdx];
            if(defender && this.checkReaction('attacked', defOwner, defender)) { if(!attacker) return; }
            if(!defender) {
                if(defOwner.units.some(u => u !== null)) { UI.log("Â£Å„ÅÇ„Çä"); return; }
                UI.log(`${attacker.data.name} Áõ¥Êé•ÊîªÊíÉ`); this.damagePlayer(defOwner, attacker.atk);
            } else {
                UI.log(`Êà¶Èóò:${attacker.atk} vs ${defender.def}`);
                if(defender.data.passive === 'reflect') { UI.log("ÂèçÊíÉ"); this.damageUnit(attacker, 2); }
                if(attacker.atk > defender.def) { UI.log("ÊíÉÁ†¥"); this.destroyUnit(defender); }
                else if (attacker.atk < defender.def) { UI.log("Ëøî„ÇäË®é„Å°"); this.destroyUnit(attacker); }
                else { UI.log("Áõ∏Êâì„Å°"); this.destroyUnit(attacker); this.destroyUnit(defender); }
            }
            this.updateStats(); UI.update();
        },
        resolveEffect(card, user, target) {
            const eff = card.data.effect; if(!eff) return;
            const opp = user.id === 'player' ? this.cpu : this.player;
            if(eff==='dmg_2') { const t = this.findBestTarget(opp.units, 'ATK'); if(t) this.damageUnit(t, 2); }
            else if(eff==='buff_def_1') card.defModPermanent += 1;
            else if(eff==='debuff_def_2') { const t = this.findBestTarget(opp.units, 'DEF'); if(t) this.damageUnit(t, 2); }
            else if(eff==='draw_1') this.draw(user, 1);
            else if(eff==='buff_def_2') card.defModPermanent += 2;
            else if(eff==='buff_atk_2_turn' && target) target.atkModTurn += 2;
            else if(eff==='dmg_3' && target) this.damageUnit(target, 3);
            else if(eff==='all_atk_1_turn') user.units.forEach(u=>{if(u) u.atkModTurn += 1;});
            else if(eff==='lock' && target) target.isLocked = true;
            else if(eff==='zero_atk' && target) target.atkModTurn = -target.baseAtk - target.atkModPermanent;
            else if(eff==='draw_2') this.draw(user, 2);
            else if(eff==='shield' && target) target.destructionImmune = true;
            else if(eff==='buff_def_3' && target) target.defModPermanent += 3;
            else if(eff==='cond_dmg' && target) { this.damageUnit(target, target.def >= 5 ? 4 : 2); }
            else if(eff==='all_def_1_turn') user.units.forEach(u=>{if(u) u.defModTurn += 1;});
            else if(eff==='react_atk_1' && target) target.atkModTurn += 1;
            else if(eff==='react_dmg_2') { const t = this.findBestTarget(opp.units, 'ATK'); if(t) this.damageUnit(t, 2); }
            else if(eff==='bounce_2') { let b = opp.units.filter(u=>u); for(let i=0;i<2;i++){ if(b.length===0)break; const idx=Math.floor(Math.random()*b.length); this.bounceUnit(b[idx]); b.splice(idx,1); } }
        },
        checkReaction(trigger, owner, targetUnit) {
            const idx = owner.reacts.findIndex(r => r && r.data.trigger === trigger); if(idx === -1) return false;
            const r = owner.reacts[idx];
            if(trigger==='full_field') { const opp = owner.id === 'player' ? this.cpu : this.player; if(opp.units.filter(u=>u).length < 3) return false; }
            UI.log(`ÁΩ†:${r.data.name}`); this.resolveEffect(r, owner, targetUnit); owner.reacts[idx] = null; return true;
        },
        updateStats() {
            [this.player, this.cpu].forEach(p => {
                const hasEnchanter = p.units.some(u => u && u.data.passive === 'aura_atk_1');
                p.units.forEach(u => { if(u) u.passiveAtk = hasEnchanter ? 1 : 0; });
            });
        },
        damageUnit(u, amt) { if(u.data.passive === 'spell_resist') amt = Math.max(0, amt - 1); if(u.destructionImmune) { UI.log("ÁÑ°Âäπ"); return; } u.damageTaken += amt; UI.floatText(u, `-${amt}`, '#ff4444'); if(u.def <= 0) this.destroyUnit(u); },
        damagePlayer(p, amt) { p.lp -= amt; UI.floatText(p.id==='player'?'player-lp':'cpu-lp', `-${amt}`, '#ff4444'); UI.update(); if(p.lp <= 0) this.endGame(p.id==='player'?'cpu':'player'); },
        destroyUnit(u) { if(u.destructionImmune){ UI.log("ÁÑ°Âäπ"); return; } const o = u.owner === 'player' ? this.player : this.cpu; const i = o.units.indexOf(u); if(i !== -1) { o.units[i] = null; UI.floatText(u, "DIE", '#888'); } },
        bounceUnit(u) { const o = u.owner === 'player' ? this.player : this.cpu; const i = o.units.indexOf(u); if(i !== -1) { o.units[i] = null; o.hand.push(new Card(u.id, u.owner)); UI.log("„Éê„Ç¶„É≥„Çπ"); } },
        findBestTarget(units, criteria) { const v = units.filter(u=>u); if(v.length===0) return null; if(criteria==='ATK') return v.sort((a,b)=>b.atk-a.atk)[0]; return v.sort((a,b)=>b.def-a.def)[0]; },
        endGame(winner) { this.gameOver = true; document.getElementById('result-screen').classList.remove('hidden'); document.getElementById('result-msg').innerText = winner === 'player' ? "YOU WIN!" : "YOU LOSE"; }
    };

    const UI={
        update(){
            this.d();
            const p=document.getElementById('player-hand');p.innerHTML='';
            window.Game.player.hand.forEach((c,i)=>{
                const e=this.c(c);
                e.onclick=()=>{
                    if(window.Game.turn!=='player'||window.Game.phase!==PHASE.MAIN)return;
                    if(window.Game.selectedCard===c){
                        if(c.data.target===TARGET.NONE&&c.data.type===TYPE.SPELL){window.Game.playCard(window.Game.player,i);window.Game.selectedCard=null;}else window.Game.selectedCard=null;
                    }else window.Game.selectedCard=c;
                    this.update();
                };
                if(window.Game.selectedCard===c)e.classList.add('selected');
                p.appendChild(e);
            });
            this.f('cpu-units',window.Game.cpu.units,'cpu',0);this.f('cpu-reacts',window.Game.cpu.reacts,'cpu',1);
            this.f('player-units',window.Game.player.units,'player',0);this.f('player-reacts',window.Game.player.reacts,'player',1);
            const b=document.getElementById('btn-next');
            if(window.Game.phase===PHASE.MAIN){b.innerText="Battle";b.disabled=window.Game.turn!=='player';}
            else if(window.Game.phase===PHASE.BATTLE){b.innerText="End Turn";b.disabled=window.Game.turn!=='player';}
            else{b.innerText="Wait";b.disabled=true;}
        },
        d(){
            document.getElementById('player-lp').innerText=window.Game.player.lp;document.getElementById('cpu-lp').innerText=window.Game.cpu.lp;
            document.getElementById('summon-cnt').innerText=window.Game.player.summonCount;document.getElementById('phase-badge').innerText=window.Game.phase;
        },
        f(id,l,o,r){
            const d=document.getElementById(id);const s=d.querySelectorAll('.slot');
            s.forEach((sl,i)=>{
                sl.innerHTML='';sl.className=r?'slot reaction':'slot';sl.onclick=null;
                const u=l[i];
                if(u){
                    const e=this.c(u);
                    if(o==='cpu'&&r)e.classList.add('face-down');
                    if(u.hasAttacked||u.isLocked)e.classList.add('exhausted');
                    if(u.destructionImmune)e.classList.add('immune');
                    if(window.Game.selectedUnit===u)e.classList.add('selected');
                    sl.appendChild(e);
                }
                if(window.Game.turn==='player'){
                    if(window.Game.phase===PHASE.MAIN&&window.Game.selectedCard){
                        const c=window.Game.selectedCard;const hi=window.Game.player.hand.indexOf(c);
                        if(o==='player'&&!r&&!u&&c.data.type===TYPE.UNIT&&window.Game.player.summonCount<2&&!window.Game.player.units.some(k=>k&&k.data.name===c.data.name)){
                            sl.classList.add('valid');sl.onclick=()=>{window.Game.playCard(window.Game.player,hi,null,i);window.Game.selectedCard=null;};
                        }
                        if(o==='player'&&r&&!u&&c.data.type===TYPE.REACT){
                            sl.classList.add('valid');sl.onclick=()=>{window.Game.playCard(window.Game.player,hi,null,i);window.Game.selectedCard=null;};
                        }
                        if(((o==='player'&&c.data.target===TARGET.ALLY)||(o==='cpu'&&c.data.target===TARGET.ENEMY))&&!r&&u){
                            sl.classList.add('valid');sl.onclick=()=>{window.Game.playCard(window.Game.player,hi,u);window.Game.selectedCard=null;};
                        }
                    }
                    if(window.Game.phase===PHASE.BATTLE){
                        if(o==='player'&&u&&!r&&u.canAttack&&!u.hasAttacked){
                            sl.style.cursor='pointer';sl.onclick=(e)=>{e.stopPropagation();window.Game.selectedUnit=u;this.update();this.log("Target?");};
                        }
                        if(o==='cpu'&&!r&&u&&window.Game.selectedUnit){
                            sl.classList.add('attack-target');sl.onclick=()=>{window.Game.attack(window.Game.selectedUnit,i);window.Game.selectedUnit=null;};
                        }
                    }
                }
            });
            if(o==='cpu'&&!r&&window.Game.phase===PHASE.BATTLE&&window.Game.selectedUnit&&!l.some(u=>u)){
                d.style.cursor='crosshair';d.onclick=(e)=>{if(e.target===d){window.Game.attack(window.Game.selectedUnit,-1);window.Game.selectedUnit=null;}};
            }
        },
        c(c){
            const e=document.createElement('div');e.className=`card ${c.data.type.toLowerCase()}`;
            e.innerHTML=`<div class="card-name">${c.data.name}</div><div class="card-art">${c.data.icon}</div><div class="card-stats">${c.data.type===TYPE.UNIT?`<span class="val-atk">‚öî${c.atk}</span><span class="val-def">üõ°${c.def}</span>`:''}</div>`;
            return e;
        },
        log(m){const d=document.createElement('div');d.className='log-line';d.innerText=m;document.getElementById('log-panel').prepend(d);},
        floatText(t,txt,c){
            const el=document.createElement('div');el.className='float-txt';el.innerText=txt;el.style.color=c;
            let p=null;
            if(t==='player-lp')p=document.querySelector('.player-info');
            else if(t==='cpu-lp')p=document.querySelector('.enemy-info');
            else if(t.uid){ const s=document.querySelectorAll('.slot'); s.forEach(sl=>{if(sl.firstChild&&sl.firstChild.innerText.includes(t.data.name))p=sl;});}
            if(p)p.appendChild(el);setTimeout(()=>el.remove(),1200);
        }
    };
</script>
</body>
</html>
