<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Arcana Flame - Nickname & Battle Fix</title>
    <style>
        /* --- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šç¾© (CSS) --- */
        :root { --bg-color: #121212; --panel-bg: #252525; --text-color: #e0e0e0; --accent-blue: #5c97f7; --accent-red: #f75c5c; --highlight: #ffd700; }
        body { margin: 0; background-color: var(--bg-color); color: var(--text-color); font-family: 'Helvetica Neue', Arial, sans-serif; overflow: hidden; user-select: none; }
        
        /* ã‚¢ãƒ—ãƒªå…¨ä½“ */
        #app { display: flex; flex-direction: column; height: 100vh; max-width: 900px; margin: 0 auto; background: #000; border-left: 1px solid #333; border-right: 1px solid #333; position: relative; }
        .hidden { display: none !important; }
        
        /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ (ãƒ­ã‚°ã‚¤ãƒ³ãƒ»ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ»ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ç”»é¢) */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        
        /* UIãƒ‘ãƒ¼ãƒ„ */
        button { cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: 0.2s; font-family: inherit; }
        button:active { transform: scale(0.98); }
        input[type="text"] { padding: 10px; font-size: 16px; border-radius: 5px; border: 1px solid #555; background: #333; color: #fff; text-align: center; margin-bottom: 10px; width: 200px;}

        .gacha-btn { padding: 15px 40px; font-size: 18px; background: linear-gradient(45deg, #f1c40f, #e67e22); color: #000; margin: 10px; box-shadow: 0 0 15px rgba(241, 196, 15, 0.4); }
        .menu-btn { padding: 10px 20px; background: #444; color: #fff; margin: 5px; min-width: 140px; border: 1px solid #666; }
        .logout-btn { padding: 5px 12px; background: #333; color: #aaa; font-size: 11px; margin-top: 15px; border: 1px solid #555; }
        
        .stone-display { font-size: 18px; color: var(--highlight); margin: 10px; padding: 5px 20px; border-radius: 20px; background: #222; border: 1px solid #444; }
        .user-header { position: absolute; top: 10px; right: 10px; font-size: 12px; color: #aaa; z-index: 300; text-align: right; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px;}

        /* ã‚¬ãƒãƒ£çµæœã‚¨ãƒªã‚¢ */
        .gacha-result { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; justify-content: center; min-height: 120px; }

        /* --- ãƒãƒˆãƒ«ç”»é¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿®æ­£ --- */
        .field-section { flex: 1; display: flex; flex-direction: column; justify-content: center; position: relative; padding: 5px 0; width: 100%; }
        .enemy-area { background: linear-gradient(to bottom, #2a1a1a, #1a0a0a); border-bottom: 2px solid #444; }
        .player-area { background: linear-gradient(to top, #1a1a2a, #0a0a1a); }
        
        .row { display: flex; justify-content: center; gap: 10px; height: 120px; align-items: center; margin: 2px 0; }
        
        /* æ‰‹æœ­ã‚¨ãƒªã‚¢ (å›ºå®šé«˜ã•ãƒ»ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«) */
        .hand-container { height: 140px; background: #080808; border-top: 2px solid #333; display: flex; justify-content: center; align-items: center; gap: 5px; overflow-x: auto; padding: 0 10px; white-space: nowrap; }

        /* ã‚¹ãƒ­ãƒƒãƒˆ & ã‚«ãƒ¼ãƒ‰ */
        .slot { width: 80px; height: 110px; border: 2px dashed #555; border-radius: 6px; position: relative; transition: 0.2s; background: rgba(255,255,255,0.03); }
        .slot.reaction { transform: scale(0.85); opacity: 0.8; border-color: #665; }
        .slot.valid { background: rgba(255, 215, 0, 0.15); border-color: var(--highlight); cursor: pointer; animation: pulse 1.5s infinite; }
        .slot.attack-target { background: rgba(255, 50, 50, 0.2); border-color: var(--accent-red); cursor: crosshair; }

        .card { width: 100%; height: 100%; background: var(--panel-bg); border: 2px solid #666; border-radius: 5px; display: flex; flex-direction: column; padding: 2px; box-sizing: border-box; font-size: 10px; cursor: pointer; position: relative; box-shadow: 0 4px 6px rgba(0,0,0,0.5); }
        .card.unit { border-top: 4px solid #a3b1b5; }
        .card.spell { border-top: 4px solid #b580d1; }
        .card.reaction { border-top: 4px solid #e08e45; }
        .card.face-down { background: repeating-linear-gradient(135deg, #222, #222 10px, #333 10px, #333 20px); border-color: #444; }
        .card.face-down * { display: none; }
        .card.exhausted { filter: grayscale(1) brightness(0.6); cursor: default; }
        .card.selected { border-color: var(--highlight); transform: translateY(-15px); box-shadow: 0 0 15px var(--highlight); z-index: 100; }
        .hand-card { flex-shrink: 0; width: 80px; height: 110px; transition: transform 0.2s; }
        .hand-card:hover { transform: translateY(-10px); z-index: 50; }

        .card-name { font-weight: bold; text-align: center; white-space: nowrap; overflow: hidden; margin-bottom: 2px; font-size: 9px; color: #fff;}
        .card-art { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 26px; background: rgba(0,0,0,0.3); margin: 1px; border-radius: 3px; }
        .card-stats { display: flex; justify-content: space-between; font-weight: bold; font-size: 11px; padding: 1px 3px; margin-top: auto; background: rgba(0,0,0,0.4); }
        .val-atk { color: #ff8888; } .val-def { color: #88aaff; }

        /* ä¸­å¤®HUD & ãƒ­ã‚° */
        .center-hud { position: absolute; top: 48%; left: 50%; transform: translate(-50%, -50%); z-index: 100; pointer-events: none; text-align: center; width: 100%; }
        #phase-badge { background: var(--accent-blue); color: #fff; padding: 5px 20px; border-radius: 15px; font-weight: bold; font-size: 20px; margin-bottom: 10px; display: inline-block; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #btn-next { pointer-events: auto; background: #eee; color: #111; padding: 8px 30px; font-size: 16px; border: 2px solid #fff; box-shadow: 0 4px 0 #999; }
        
        #log-panel { position: absolute; bottom: 150px; right: 10px; width: 220px; height: 120px; background: rgba(0,0,0,0.85); border: 1px solid #555; overflow-y: auto; pointer-events: none; z-index: 50; font-size: 11px; color: #ccc; display: flex; flex-direction: column-reverse; padding: 5px; border-radius: 5px; }
        .log-line { border-bottom: 1px solid #444; margin-bottom: 2px; padding-bottom: 1px; }

        /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ */
        .float-txt { position: absolute; font-weight: bold; font-size: 22px; animation: floatUp 1.2s forwards; z-index: 150; pointer-events: none; text-shadow: 2px 2px 0 #000; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        @keyframes floatUp { 0% { transform:translateY(0) scale(1); opacity:1; } 100% { transform:translateY(-50px) scale(1.5); opacity:0; } }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
        .lp-display { position: absolute; font-weight: bold; font-size: 14px; background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px; border: 1px solid #555; }
        .enemy-lp { top: 10px; left: 10px; color: var(--accent-red); }
        .player-lp { bottom: 10px; left: 10px; color: var(--accent-blue); }
    </style>
</head>
<body>

<!-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ˜ãƒƒãƒ€ãƒ¼ -->
<div class="user-header">
    <span id="display-name">Guest</span><br>
    ğŸ’ <span id="header-stones">0</span>
</div>

<!-- 1. ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ -->
<div id="login-screen" class="overlay">
    <h1 style="color:var(--highlight); font-size:36px; margin-bottom:10px;">ARCANA FLAME</h1>
    <p style="color:#aaa; margin-bottom:30px;">Online TCG Battle</p>
    <button class="gacha-btn" onclick="Auth.login()">Googleã§ãƒ­ã‚°ã‚¤ãƒ³</button>
</div>

<!-- 1.5 ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ç™»éŒ²ç”»é¢ -->
<div id="nickname-screen" class="overlay hidden">
    <h2>ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ç™»éŒ²</h2>
    <p style="font-size:12px; color:#aaa; margin-bottom:15px;">ã‚²ãƒ¼ãƒ å†…ã§è¡¨ç¤ºã•ã‚Œã‚‹åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
    <input type="text" id="nickname-input" placeholder="å…¨è§’ãƒ»åŠè§’ 8æ–‡å­—ä»¥å†…" maxlength="8">
    <button class="menu-btn" onclick="Auth.setNickname()">æ±ºå®š</button>
</div>

<!-- 2. ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ -->
<div id="menu-screen" class="overlay hidden">
    <h2 style="border-bottom:2px solid var(--highlight); padding-bottom:5px;">MAIN MENU</h2>
    
    <!-- ã‚¬ãƒãƒ£ã‚¨ãƒªã‚¢ -->
    <div style="background:#222; padding:20px; border-radius:10px; border:1px solid #444; text-align:center; margin:20px 0;">
        <div class="stone-display">æ‰€æŒé­”æ³•çŸ³: <span id="menu-stones">0</span></div>
        <button class="gacha-btn" onclick="Gacha.pull()">ãƒ‘ãƒƒã‚¯ã‚’å¼•ã (100ğŸ’)</button>
        <br>
        <button id="bonus-btn" class="menu-btn" onclick="Gacha.addFreeStones()">ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹</button>
        <div class="gacha-result" id="gacha-result"></div>
    </div>

    <!-- ãƒãƒˆãƒ«ã‚¨ãƒªã‚¢ -->
    <div>
        <p>â–¼ ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãƒãƒˆãƒ«é–‹å§‹</p>
        <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
            <button class="menu-btn" onclick="Game.start(0)">ğŸ”¥ çƒˆç«ã®ãƒ‰ãƒ©ã‚´ãƒ³</button>
            <button class="menu-btn" onclick="Game.start(1)">ğŸ”® æŠ€å·§ã®é­”è¡“å¸«</button>
            <button class="menu-btn" onclick="Game.start(2)">ğŸ›¡ï¸ é‰„å£ã®ãƒ“ãƒ¼ã‚¹ãƒˆ</button>
        </div>
    </div>
    
    <button class="logout-btn" onclick="Auth.logout()">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
</div>

<!-- 3. ã‚²ãƒ¼ãƒ ç”»é¢ -->
<div id="game-app" class="hidden">
    <!-- æ•µã‚¨ãƒªã‚¢ -->
    <div class="field-section enemy-area">
        <div class="lp-display enemy-lp">CPU LP: <span id="cpu-lp">12</span></div>
        <div class="row" id="cpu-units"><div class="slot" data-i="0"></div><div class="slot" data-i="1"></div><div class="slot" data-i="2"></div></div>
        <div class="row" id="cpu-reacts" style="height:90px;"><div class="slot reaction" data-i="0"></div><div class="slot reaction" data-i="1"></div></div>
    </div>

    <!-- ä¸­å¤®HUD -->
    <div class="center-hud">
        <div id="phase-badge">START</div><br>
        <button id="btn-next" onclick="Game.nextPhase()">Start</button>
    </div>

    <!-- è‡ªåˆ†ã‚¨ãƒªã‚¢ -->
    <div class="field-section player-area">
        <div class="row" id="player-reacts" style="height:90px;"><div class="slot reaction" data-i="0"></div><div class="slot reaction" data-i="1"></div></div>
        <div class="row" id="player-units"><div class="slot" data-i="0"></div><div class="slot" data-i="1"></div><div class="slot" data-i="2"></div></div>
        <div class="lp-display player-lp">
            YOU: <span id="player-lp">12</span> <span style="font-size:10px; color:#aaa;">(Summon: <span id="summon-cnt">0</span>/2)</span>
        </div>
    </div>

    <!-- æ‰‹æœ­ã‚¨ãƒªã‚¢ -->
    <div class="hand-container" id="player-hand"></div>
    
    <!-- ãƒ­ã‚° -->
    <div id="log-panel"></div>
    
    <!-- ãƒªã‚¿ã‚¤ã‚¢ãƒœã‚¿ãƒ³ -->
    <button class="menu-btn" style="position:absolute; top:10px; left:10px; z-index:300; min-width:60px; font-size:11px; padding:5px;" onclick="location.reload()">RETIRE</button>
    
    <!-- ãƒªã‚¶ãƒ«ãƒˆç”»é¢ -->
    <div id="result-screen" class="overlay hidden">
        <h1 id="result-msg" style="font-size:48px; text-shadow:0 0 10px #fff;"></h1>
        <button class="menu-btn" onclick="location.reload()">TITLE SCREEN</button>
    </div>
</div>

<!-- 4. JavaScript Logic -->
<script type="module">
    // Firebase Imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { getAuth, signInWithPopup, signOut, GoogleAuthProvider, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, arrayUnion, increment } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

    // â˜…â˜…â˜… Firebase Config (ã‚ãªãŸã®è¨­å®šã«æ›¸ãæ›ãˆã¦ãã ã•ã„) â˜…â˜…â˜…
const firebaseConfig = {
  apiKey: "AIzaSyCNgyBeSzbc74e6iWNnY0irswl24ciAfcg",
  authDomain: "arcana-flame-game.firebaseapp.com",
  projectId: "arcana-flame-game",
  storageBucket: "arcana-flame-game.firebasestorage.app",
  messagingSenderId: "562804440230",
  appId: "1:562804440230:web:26f7bd08ea47d39ad80867",
  measurementId: "G-XT2EDR06R1"
};

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();

    // ----------------------------------------------------------------
    // Data Definitions
    // ----------------------------------------------------------------
    const TYPE = { UNIT: 'UNIT', SPELL: 'SPELL', REACT: 'REACT' };
    const TARGET = { NONE: 'NONE', ENEMY: 'ENEMY', ALLY: 'ALLY', ANY: 'ANY' };
    const PHASE = { DRAW: 'DRAW', MAIN: 'MAIN', BATTLE: 'BATTLE', END: 'END' };

    const DB = {
        'd01': { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ãƒ»ãƒ‰ãƒ©ã‚´ãƒ³', type: TYPE.UNIT, atk: 3, def: 3, icon: 'ğŸ²', desc: '-', target: TARGET.NONE },
        'd02': { name: 'ãƒœãƒ«ã‚«ãƒ‹ãƒƒã‚¯ãƒ»ãƒ¯ã‚¤ãƒãƒ¼ãƒ³', type: TYPE.UNIT, atk: 4, def: 2, icon: 'ğŸ¦–', desc: '-', target: TARGET.NONE },
        'd03': { name: 'ã‚¬ãƒ¼ãƒ‰ã‚¹ã‚±ã‚¤ãƒ«ãƒ»ãƒ‰ãƒ©ã‚´ãƒ³', type: TYPE.UNIT, atk: 2, def: 5, icon: 'ğŸ›¡ï¸', desc: '-', target: TARGET.NONE },
        'd04': { name: 'ãƒ«ãƒ“ãƒ¼ãƒ›ãƒ¼ãƒ³ãƒ»ãƒ‰ãƒ©ã‚´ãƒ³', type: TYPE.UNIT, atk: 3, def: 4, icon: 'ğŸ‚', desc: '-', target: TARGET.NONE },
        'd05': { name: 'ã‚½ãƒ¼ãƒ©ãƒ¼ãƒ–ãƒ¬ã‚¤ã‚º', type: TYPE.UNIT, atk: 5, def: 3, icon: 'ğŸŒ', desc: 'å¬å–š:æ•µ2ãƒ€ãƒ¡', effect: 'dmg_2', target: TARGET.NONE },
        's01': { name: 'ãƒ‰ãƒ©ã‚´ãƒ³ãƒ»ãƒ•ã‚©ãƒ¼ã‚¹', type: TYPE.SPELL, icon: 'ğŸ’ª', desc: 'å‘³æ–¹ATK+2(T)', effect: 'buff_atk_2_turn', target: TARGET.ALLY },
        's02': { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ãƒãƒ¼ã‚¹ãƒˆ', type: TYPE.SPELL, icon: 'ğŸ”¥', desc: 'æ•µ3ãƒ€ãƒ¡', effect: 'dmg_3', target: TARGET.ENEMY },
        's03': { name: 'ç†±é¢¨ã®å·ä»¤', type: TYPE.SPELL, icon: 'ğŸŒ¬ï¸', desc: 'å…¨å‘³æ–¹ATK+1(T)', effect: 'all_atk_1_turn', target: TARGET.NONE },
        'r01': { name: 'ãƒ‰ãƒ©ã‚´ãƒ³ã®å’†å“®', type: TYPE.REACT, icon: 'ğŸ“¢', desc: 'è¢«å¼¾:ATK+1(T)', trigger: 'attacked', effect: 'react_atk_1' },

        'm01': { name: 'ã‚¢ãƒ¼ã‚¯ãƒ»ã‚¢ãƒ—ãƒ¬ãƒ³ãƒ†ã‚£ã‚¹', type: TYPE.UNIT, atk: 2, def: 2, icon: 'ğŸ§™', desc: 'å¬å–š:å‘³æ–¹DEF+1', effect: 'buff_def_1', target: TARGET.NONE },
        'm02': { name: 'ã‚¯ãƒ­ãƒãƒãƒ³ã‚µãƒ¼', type: TYPE.UNIT, atk: 1, def: 3, icon: 'â³', desc: 'æ°¸ç¶š:é­”è»½æ¸›1', passive: 'spell_resist', target: TARGET.NONE },
        'm03': { name: 'ãƒ«ãƒ¼ãƒ³ãƒ»ã‚¨ãƒ³ãƒãƒ£ãƒ³ã‚¿ãƒ¼', type: TYPE.UNIT, atk: 2, def: 3, icon: 'âœ¨', desc: 'æ°¸ç¶š:å‘³æ–¹ATK+1', passive: 'aura_atk_1', target: TARGET.NONE },
        'm04': { name: 'ãƒã‚®ã‚¢ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ã‚¹ãƒˆ', type: TYPE.UNIT, atk: 3, def: 2, icon: 'ğŸ“–', desc: 'å¬å–š:1ãƒ‰ãƒ­ãƒ¼', effect: 'draw_1', target: TARGET.NONE },
        'm05': { name: 'å¤§è³¢è€…ã‚ªãƒ«ãƒ‡ã‚£ãƒ³', type: TYPE.UNIT, atk: 4, def: 4, icon: 'ğŸ‘´', desc: 'å¬å–š:æ•µDEF-2', effect: 'debuff_def_2', target: TARGET.NONE },
        's11': { name: 'å°å°ã®é–ƒå…‰', type: TYPE.SPELL, icon: 'ğŸ”’', desc: 'æ•µæ”»æ’ƒä¸å¯(T)', effect: 'lock', target: TARGET.ENEMY },
        's12': { name: 'ãƒ‡ã‚£ã‚¹ã‚¸ãƒ£ãƒ³ã‚¯ã‚·ãƒ§ãƒ³', type: TYPE.SPELL, icon: 'ğŸš«', desc: 'æ•µATK0(T)', effect: 'zero_atk', target: TARGET.ENEMY },
        's13': { name: 'é­”å°è§£æ', type: TYPE.SPELL, icon: 'ğŸ“š', desc: '2ãƒ‰ãƒ­ãƒ¼', effect: 'draw_2', target: TARGET.NONE },
        's14': { name: 'ãƒãƒŠã‚·ãƒ¼ãƒ«ãƒ‰', type: TYPE.SPELL, icon: 'ğŸ›¡ï¸', desc: 'å‘³æ–¹ç ´å£Šç„¡åŠ¹(T)', effect: 'shield', target: TARGET.ALLY },
        'r11': { name: 'åè»¢ã®çµç•Œ', type: TYPE.REACT, icon: 'ğŸ›‘', desc: 'é­”æ³•ç„¡åŠ¹åŒ–', trigger: 'spell', effect: 'negate' },
        'r12': { name: 'ã‚¢ã‚¹ãƒˆãƒ©ãƒ«ã‚µã‚¤ã‚¯ãƒ«', type: TYPE.REACT, icon: 'ğŸŒŒ', desc: 'æ•µ3ä½“:2ä½“æˆ»ã™', trigger: 'full_field', effect: 'bounce_2' },

        'b01': { name: 'ã‚·ãƒ¼ãƒ«ãƒ‰ãƒ™ã‚¢', type: TYPE.UNIT, atk: 2, def: 5, icon: 'ğŸ»', desc: '-', target: TARGET.NONE },
        'b02': { name: 'ã‚¢ã‚¤ã‚¢ãƒ³ãƒ•ã‚¡ãƒ³ã‚°', type: TYPE.UNIT, atk: 3, def: 4, icon: 'ğŸº', desc: '-', target: TARGET.NONE },
        'b03': { name: 'ãƒªãƒšã‚¢ãƒ›ãƒ¼ãƒ³', type: TYPE.UNIT, atk: 1, def: 4, icon: 'ğŸ¦„', desc: 'å¬å–š:å‘³æ–¹DEF+2', effect: 'buff_def_2', target: TARGET.NONE },
        'b04': { name: 'ãƒ­ãƒƒã‚¯ã‚¸ãƒ£ã‚¦', type: TYPE.UNIT, atk: 3, def: 6, icon: 'ğŸ—¿', desc: '-', target: TARGET.NONE },
        'b05': { name: 'ã‚¿ã‚¤ã‚¿ãƒ³', type: TYPE.UNIT, atk: 4, def: 7, icon: 'ğŸ‘¹', desc: 'åæ’ƒ2ãƒ€ãƒ¡', passive: 'reflect', target: TARGET.NONE },
        's21': { name: 'ãƒ•ã‚©ãƒ¼ãƒˆãƒ¬ã‚¹', type: TYPE.SPELL, icon: 'ğŸ°', desc: 'å‘³æ–¹DEF+3', effect: 'buff_def_3', target: TARGET.ALLY },
        's22': { name: 'ã‚¢ã‚¤ã‚¢ãƒ³ã‚¹ãƒãƒƒã‚·ãƒ¥', type: TYPE.SPELL, icon: 'ğŸ”¨', desc: 'æ•µ2or4ãƒ€ãƒ¡', effect: 'cond_dmg', target: TARGET.ENEMY },
        's23': { name: 'ãƒãƒªã‚¢ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', type: TYPE.SPELL, icon: 'ğŸŒ', desc: 'å…¨å‘³æ–¹DEF+1(T)', effect: 'all_def_1_turn', target: TARGET.NONE },
        'r21': { name: 'å …ç‰¢ãªã‚‹åæ’ƒ', type: TYPE.REACT, icon: 'âš”ï¸', desc: 'è¢«å¼¾:æ•µ2ãƒ€ãƒ¡', trigger: 'attacked', effect: 'react_dmg_2' }
    };

    const DECK_LISTS = [
        ['d01','d01','d01', 'd02','d02','d02', 'd03','d03', 'd04','d04', 'd05','d05', 's01','s01', 's02','s02', 's03','s03', 'r01','r01'],
        ['m01','m01','m01', 'm02','m02', 'm03','m03','m03', 'm04','m04', 'm05','m05', 's11','s11', 's12','s12', 's13', 's14', 'r11', 'r12'],
        ['b01','b01','b01', 'b02','b02','b02', 'b03','b03', 'b04','b04', 'b05','b05', 's21','s21', 's22','s22', 's23','s23', 'r21','r21']
    ];

    // ----------------------------------------------------------------
    // Auth & Gacha System
    // ----------------------------------------------------------------
    window.Auth = {
        user: null,
        nickname: null,

        async login() {
            try { await signInWithPopup(auth, provider); } 
            catch (e) { alert("ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: " + e.message); }
        },
        async logout() {
            try { await signOut(auth); location.reload(); } 
            catch (e) { alert("ã‚¨ãƒ©ãƒ¼: " + e.message); }
        },
        async setNickname() {
            const input = document.getElementById('nickname-input');
            const name = input.value.trim();
            if (!name) return alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            
            try {
                const uid = this.user.uid;
                await updateDoc(doc(db, "users", uid), { nickname: name });
                this.nickname = name;
                this.updateNameDisplay();
                document.getElementById('nickname-screen').classList.add('hidden');
                document.getElementById('menu-screen').classList.remove('hidden');
            } catch (e) { console.error(e); alert("ç™»éŒ²ã‚¨ãƒ©ãƒ¼"); }
        },
        updateNameDisplay() {
            document.getElementById('display-name').innerText = this.nickname || "Guest";
        }
    };

    onAuthStateChanged(auth, async (user) => {
        if (user) {
            window.Auth.user = user;
            document.getElementById('login-screen').classList.add('hidden');
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿å–å¾—
            await Gacha.loadUserData(user.uid);
            
            // ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ æœªç™»éŒ²ãªã‚‰ç™»éŒ²ç”»é¢ã¸ã€ã‚ã‚Œã°ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸
            if (!window.Auth.nickname) {
                document.getElementById('nickname-screen').classList.remove('hidden');
            } else {
                document.getElementById('menu-screen').classList.remove('hidden');
            }
        }
    });

    window.Gacha = {
        stones: 0,
        collection: [],
        lastBonusDate: null,

        async loadUserData(uid) {
            try {
                const userRef = doc(db, "users", uid);
                const docSnap = await getDoc(userRef);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    this.stones = data.stones || 0;
                    this.collection = data.collection || [];
                    this.lastBonusDate = data.lastBonusDate || null;
                    window.Auth.nickname = data.nickname || null;
                } else {
                    // æ–°è¦ä½œæˆ
                    this.stones = 3000;
                    this.collection = [];
                    await setDoc(userRef, { stones: 3000, collection: [], lastBonusDate: null, nickname: null });
                }
                this.updateDisplay();
                window.Auth.updateNameDisplay();
                this.checkBonusButton();
            } catch (e) { console.error("Load Error:", e); }
        },

        updateDisplay() {
            document.getElementById('header-stones').innerText = this.stones;
            document.getElementById('menu-stones').innerText = this.stones;
        },

        checkBonusButton() {
            const today = new Date().toDateString();
            const btn = document.getElementById('bonus-btn');
            if (this.lastBonusDate === today) {
                btn.disabled = true; btn.innerText = "å—å–æ¸ˆã¿";
            } else {
                btn.disabled = false; btn.innerText = "ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ (+500ğŸ’)";
            }
        },

        async addFreeStones() {
            if(!window.Auth.user) return;
            const today = new Date().toDateString();
            if (this.lastBonusDate === today) return;

            this.stones += 500;
            this.lastBonusDate = today;
            this.updateDisplay();
            this.checkBonusButton();
            
            await updateDoc(doc(db, "users", window.Auth.user.uid), { stones: increment(500), lastBonusDate: today });
            alert("ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ã‚’å—ã‘å–ã‚Šã¾ã—ãŸï¼");
        },

        async pull() {
            if (this.stones < 100) return alert("çŸ³ãŒè¶³ã‚Šã¾ã›ã‚“ï¼");
            this.stones -= 100;
            this.updateDisplay();

            const keys = Object.keys(DB);
            const hitId = keys[Math.floor(Math.random() * keys.length)];
            const d = DB[hitId];
            this.collection.push(hitId);

            await updateDoc(doc(db, "users", window.Auth.user.uid), { stones: increment(-100), collection: arrayUnion(hitId) });

            const resDiv = document.getElementById('gacha-result');
            resDiv.innerHTML = `
                <div style="text-align:center; animation:pulse 0.5s;">
                    <div style="color:#888; font-size:10px;">GET!</div>
                    <div class="card ${d.type==='UNIT'?'unit':(d.type==='SPELL'?'spell':'reaction')}" style="width:80px; height:110px;">
                        <div class="card-name">${d.name}</div><div class="card-art">${d.icon}</div>
                        <div class="card-stats">${d.type==='UNIT'?`<span class="val-atk">âš”${d.atk}</span><span class="val-def">ğŸ›¡${d.def}</span>`:''}</div>
                    </div>
                </div>`;
        }
    };

    // ----------------------------------------------------------------
    // Game Logic
    // ----------------------------------------------------------------
    class Card {
        constructor(id, owner) {
            this.id = id; this.data = DB[id]; this.owner = owner;
            this.uid = Math.random().toString(36).substr(2, 9);
            this.baseAtk = this.data.atk || 0; this.baseDef = this.data.def || 0;
            this.atkModPermanent = 0; this.atkModTurn = 0; this.defModPermanent = 0; this.defModTurn = 0; this.damageTaken = 0;
            this.canAttack = true; this.hasAttacked = false; this.isLocked = false; this.destructionImmune = false;
        }
        get atk() { return Math.max(0, this.baseAtk + this.atkModPermanent + this.atkModTurn + (this.passiveAtk || 0)); }
        get def() { return (this.baseDef + this.defModPermanent + this.defModTurn) - this.damageTaken; }
        resetTurn() { this.hasAttacked = false; this.canAttack = !this.isLocked; this.isLocked = false; this.destructionImmune = false; this.atkModTurn = 0; this.defModTurn = 0; }
    }

    const AI = {
        act() {
            if(window.Game.turn !== 'cpu') return;
            const cpu = window.Game.cpu;
            const opp = window.Game.player;

            // Summon
            const units = cpu.hand.map((c,i)=>({c,i})).filter(o=>o.c.data.type === TYPE.UNIT);
            const playable = units.filter(o => !cpu.units.some(u => u && u.data.name === o.c.data.name));
            if(playable.length > 0 && cpu.summonCount < 2) {
                playable.sort((a,b) => (b.c.atk+b.c.def) - (a.c.atk+a.c.def));
                const slot = cpu.units.findIndex(u=>u===null);
                if(slot !== -1) {
                    window.Game.playCard(cpu, playable[0].i, null, slot);
                    setTimeout(()=>this.act(), 800);
                    return;
                }
            }
            // Spells
            const spells = cpu.hand.map((c,i)=>({c,i})).filter(o=>o.c.data.type !== TYPE.UNIT);
            if(spells.length > 0) {
                const s = spells[0];
                if(s.c.data.type === TYPE.REACT) {
                    const slot = cpu.reacts.findIndex(r=>r===null);
                    if(slot !== -1) window.Game.playCard(cpu, s.i, null, slot);
                } else {
                    let t = null;
                    if(s.c.data.target === TARGET.ENEMY) t = window.Game.findBestTarget(opp.units, 'ATK');
                    if(s.c.data.target === TARGET.ALLY) t = window.Game.findBestTarget(cpu.units, 'ATK');
                    if(s.c.data.target === TARGET.NONE || t) window.Game.playCard(cpu, s.i, t);
                }
            }
            setTimeout(()=>window.Game.nextPhase(), 1200);
        },
        battle() {
            if(window.Game.turn !== 'cpu') return;
            const atts = window.Game.cpu.units.filter(u=>u && u.canAttack && !u.hasAttacked);
            if(atts.length === 0) { setTimeout(()=>window.Game.nextPhase(), 600); return; }

            atts.sort((a,b)=>b.atk - a.atk);
            const att = atts[0];
            const enemies = window.Game.player.units.map((u,i)=>({u,i})).filter(o=>o.u);
            let tIdx = -2;

            if(enemies.length === 0) tIdx = -1;
            else {
                const kills = enemies.filter(e => att.atk > e.u.def);
                if(kills.length > 0) {
                    kills.sort((a,b)=>b.u.atk - a.u.atk); tIdx = kills[0].i;
                } else {
                    const trades = enemies.filter(e => att.atk === e.u.def && e.u.atk >= att.atk);
                    if(trades.length > 0) tIdx = trades[0].i;
                }
            }

            if(tIdx !== -2) window.Game.attack(att, tIdx);
            else att.hasAttacked = true;

            setTimeout(()=>this.battle(), 1000);
        }
    };

    window.Game = {
        player: null, cpu: null, turn: 'player', phase: PHASE.DRAW, selectedCard: null, selectedUnit: null, gameOver: false, firstTurn: true,

        start(deckIdx) {
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-app').classList.remove('hidden');
            
            const createPlayer = (id, dIdx) => ({ id, lp: 12, deck: this.shuffle(DECK_LISTS[dIdx].map(cid => new Card(cid, id))), hand: [], units: [null, null, null], reacts: [null, null], summonCount: 0 });
            this.player = createPlayer('player', deckIdx);
            let cpuDeckIdx = (deckIdx + 1 + Math.floor(Math.random()*2)) % 3;
            this.cpu = createPlayer('cpu', cpuDeckIdx);

            for(let i=0; i<4; i++) { this.draw(this.player); this.draw(this.cpu); }
            this.turn = Math.random() < 0.5 ? 'player' : 'cpu';
            UI.log(`Game Start! å…ˆæ”»: ${this.turn.toUpperCase()}`);
            this.startTurn();
        },
        shuffle(arr) { for(let i=arr.length-1; i>0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; },
        draw(p, amt=1) { for(let i=0; i<amt; i++) { if(p.deck.length > 0) p.hand.push(p.deck.pop()); else this.endGame(p.id === 'player' ? 'cpu' : 'player'); } },
        startTurn() {
            this.phase = PHASE.DRAW;
            const p = this.turn === 'player' ? this.player : this.cpu;
            p.summonCount = 0;
            [this.player, this.cpu].forEach(pl => pl.units.forEach(u => { if(u) u.resetTurn(); }));
            this.updateStats(); UI.update();
            setTimeout(() => {
                if(this.firstTurn) { this.firstTurn = false; UI.log("å…ˆæ”»1T:ãƒ‰ãƒ­ãƒ¼ã‚¹ã‚­ãƒƒãƒ—"); } else { this.draw(p); }
                this.phase = PHASE.MAIN; UI.update();
                if(this.turn === 'cpu') AI.act();
            }, 800);
        },
        nextPhase() {
            if(this.gameOver) return;
            if(this.phase === PHASE.MAIN) { this.phase = PHASE.BATTLE; UI.update(); if(this.turn === 'cpu') AI.battle(); }
            else if(this.phase === PHASE.BATTLE) { this.phase = PHASE.END; this.turn = this.turn === 'player' ? 'cpu' : 'player'; this.startTurn(); }
        },
        playCard(p, handIdx, tUnit=null, sIdx=null) {
            const card = p.hand[handIdx]; if(!card) return;
            if(card.data.type === TYPE.UNIT) {
                if(p.summonCount >= 2) { UI.log("å¬å–šæ¨©ãªã—"); return; }
                if(p.units[sIdx] !== null || p.units.some(u => u && u.data.name === card.data.name)) { UI.log("å¬å–šä¸å¯"); return; }
            }
            const opp = p.id === 'player' ? this.cpu : this.player;
            if(card.data.type === TYPE.SPELL && this.checkReaction('spell', opp, null)) { p.hand.splice(handIdx, 1); UI.log("ç„¡åŠ¹åŒ–"); UI.update(); return; }
            p.hand.splice(handIdx, 1);
            if(card.data.type === TYPE.UNIT) { p.units[sIdx] = card; p.summonCount++; UI.log(`å¬å–š:${card.data.name}`); this.resolveEffect(card, p, null); this.checkReaction('full_field', opp, null); }
            else if(card.data.type === TYPE.SPELL) { UI.log(`ç™ºå‹•:${card.data.name}`); this.resolveEffect(card, p, tUnit); }
            else if(card.data.type === TYPE.REACT) { p.reacts[sIdx] = card; UI.log(`ã‚»ãƒƒãƒˆ:${card.data.name}`); }
            this.updateStats(); UI.update();
        },
        attack(attacker, targetIdx) {
            if(!attacker.canAttack || attacker.hasAttacked) return;
            attacker.hasAttacked = true;
            const defOwner = attacker.owner === 'player' ? this.cpu : this.player;
            const defender = targetIdx === -1 ? null : defOwner.units[targetIdx];
            if(defender && this.checkReaction('attacked', defOwner, defender)) { if(!attacker) return; }
            if(!defender) {
                if(defOwner.units.some(u => u !== null)) { UI.log("å£ã‚ã‚Š"); return; }
                UI.log(`${attacker.data.name} ç›´æ¥æ”»æ’ƒ`); this.damagePlayer(defOwner, attacker.atk);
            } else {
                UI.log(`æˆ¦é—˜:${attacker.atk} vs ${defender.def}`);
                if(defender.data.passive === 'reflect') { UI.log("åæ’ƒ"); this.damageUnit(attacker, 2); }
                if(attacker.atk > defender.def) { UI.log("æ’ƒç ´"); this.destroyUnit(defender); }
                else if (attacker.atk < defender.def) { UI.log("è¿”ã‚Šè¨ã¡"); this.destroyUnit(attacker); }
                else { UI.log("ç›¸æ‰“ã¡"); this.destroyUnit(attacker); this.destroyUnit(defender); }
            }
            this.updateStats(); UI.update();
        },
        resolveEffect(card, user, target) {
            const eff = card.data.effect; if(!eff) return;
            const opp = user.id === 'player' ? this.cpu : this.player;
            if(eff==='dmg_2') { const t = this.findBestTarget(opp.units, 'ATK'); if(t) this.damageUnit(t, 2); }
            else if(eff==='buff_def_1') card.defModPermanent += 1;
            else if(eff==='debuff_def_2') { const t = this.findBestTarget(opp.units, 'DEF'); if(t) this.damageUnit(t, 2); }
            else if(eff==='draw_1') this.draw(user, 1);
            else if(eff==='buff_def_2') card.defModPermanent += 2;
            else if(eff==='buff_atk_2_turn' && target) target.atkModTurn += 2;
            else if(eff==='dmg_3' && target) this.damageUnit(target, 3);
            else if(eff==='all_atk_1_turn') user.units.forEach(u=>{if(u) u.atkModTurn += 1;});
            else if(eff==='lock' && target) target.isLocked = true;
            else if(eff==='zero_atk' && target) target.atkModTurn = -target.baseAtk - target.atkModPermanent;
            else if(eff==='draw_2') this.draw(user, 2);
            else if(eff==='shield' && target) target.destructionImmune = true;
            else if(eff==='buff_def_3' && target) target.defModPermanent += 3;
            else if(eff==='cond_dmg' && target) { this.damageUnit(target, target.def >= 5 ? 4 : 2); }
            else if(eff==='all_def_1_turn') user.units.forEach(u=>{if(u) u.defModTurn += 1;});
            else if(eff==='react_atk_1' && target) target.atkModTurn += 1;
            else if(eff==='react_dmg_2') { const t = this.findBestTarget(opp.units, 'ATK'); if(t) this.damageUnit(t, 2); }
            else if(eff==='bounce_2') { let b = opp.units.filter(u=>u); for(let i=0;i<2;i++){ if(b.length===0)break; const idx=Math.floor(Math.random()*b.length); this.bounceUnit(b[idx]); b.splice(idx,1); } }
        },
        checkReaction(trigger, owner, targetUnit) {
            const idx = owner.reacts.findIndex(r => r && r.data.trigger === trigger); if(idx === -1) return false;
            const r = owner.reacts[idx];
            if(trigger==='full_field') { const opp = owner.id === 'player' ? this.cpu : this.player; if(opp.units.filter(u=>u).length < 3) return false; }
            UI.log(`ç½ :${r.data.name}`); this.resolveEffect(r, owner, targetUnit); owner.reacts[idx] = null; return true;
        },
        updateStats() {
            [this.player, this.cpu].forEach(p => {
                const hasAura = p.units.some(u => u && u.data.passive === 'aura_atk_1');
                p.units.forEach(u => { if(u) u.passiveAtk = hasAura ? 1 : 0; });
            });
        },
        damageUnit(u, amt) { if(u.data.passive === 'spell_resist') amt = Math.max(0, amt - 1); if(u.destructionImmune) { UI.log("ç„¡åŠ¹"); return; } u.damageTaken += amt; UI.floatText(u, `-${amt}`, '#ff4444'); if(u.def <= 0) this.destroyUnit(u); },
        damagePlayer(p, amt) { p.lp -= amt; UI.floatText(p.id==='player'?'player-lp':'cpu-lp', `-${amt}`, '#ff4444'); UI.update(); if(p.lp <= 0) this.endGame(p.id==='player'?'cpu':'player'); },
        destroyUnit(u) { if(u.destructionImmune){ UI.log("ç„¡åŠ¹"); return; } const o = u.owner === 'player' ? this.player : this.cpu; const i = o.units.indexOf(u); if(i !== -1) { o.units[i] = null; UI.floatText(u, "DIE", '#888'); } },
        bounceUnit(u) { const o = u.owner === 'player' ? this.player : this.cpu; const i = o.units.indexOf(u); if(i !== -1) { o.units[i] = null; o.hand.push(new Card(u.id, u.owner)); UI.log("ãƒã‚¦ãƒ³ã‚¹"); } },
        findBestTarget(units, criteria) { const v = units.filter(u=>u); if(v.length===0) return null; if(criteria==='ATK') return v.sort((a,b)=>b.atk-a.atk)[0]; return v.sort((a,b)=>b.def-a.def)[0]; },
        endGame(winner) { this.gameOver = true; document.getElementById('result-screen').classList.remove('hidden'); document.getElementById('result-msg').innerText = winner === 'player' ? "YOU WIN!" : "YOU LOSE"; }
    };

    const UI={
        update(){
            document.getElementById('player-lp').innerText=window.Game.player.lp; document.getElementById('cpu-lp').innerText=window.Game.cpu.lp;
            document.getElementById('summon-cnt').innerText=window.Game.player.summonCount; document.getElementById('phase-badge').innerText=window.Game.phase;
            const ph=document.getElementById('player-hand'); ph.innerHTML='';
            window.Game.player.hand.forEach((c,i)=>{
                const e=this.c(c); e.classList.add('hand-card');
                e.onclick=()=>{
                    if(window.Game.turn!=='player'||window.Game.phase!==PHASE.MAIN)return;
                    if(window.Game.selectedCard===c){ if(c.data.target===TARGET.NONE&&c.data.type===TYPE.SPELL){window.Game.playCard(window.Game.player,i);window.Game.selectedCard=null;}else window.Game.selectedCard=null; }
                    else window.Game.selectedCard=c; this.update();
                };
                if(window.Game.selectedCard===c)e.classList.add('selected'); ph.appendChild(e);
            });
            this.f('cpu-units',window.Game.cpu.units,'cpu',0); this.f('cpu-reacts',window.Game.cpu.reacts,'cpu',1);
            this.f('player-units',window.Game.player.units,'player',0); this.f('player-reacts',window.Game.player.reacts,'player',1);
            const b=document.getElementById('btn-next');
            if(window.Game.phase===PHASE.MAIN){b.innerText="Battle";b.disabled=window.Game.turn!=='player';}
            else if(window.Game.phase===PHASE.BATTLE){b.innerText="End Turn";b.disabled=window.Game.turn!=='player';}
            else{b.innerText="Wait";b.disabled=true;}
        },
        f(id,l,o,r){
            const d=document.getElementById(id);const s=d.querySelectorAll('.slot');
            s.forEach((sl,i)=>{
                sl.innerHTML='';sl.className=r?'slot reaction':'slot';sl.onclick=null;
                const u=l[i];
                if(u){
                    const e=this.c(u);
                    if(o==='cpu'&&r)e.classList.add('face-down');
                    if(u.hasAttacked||u.isLocked)e.classList.add('exhausted');
                    if(u.destructionImmune)e.style.boxShadow="0 0 5px #5c97f7";
                    if(window.Game.selectedUnit===u)e.classList.add('selected');
                    sl.appendChild(e);
                }
                if(window.Game.turn==='player'){
                    if(window.Game.phase===PHASE.MAIN&&window.Game.selectedCard){
                        const c=window.Game.selectedCard; const hi=window.Game.player.hand.indexOf(c);
                        if(o==='player'&&!r&&!u&&c.data.type===TYPE.UNIT&&window.Game.player.summonCount<2&&!window.Game.player.units.some(k=>k&&k.data.name===c.data.name)){sl.classList.add('valid');sl.onclick=()=>{window.Game.playCard(window.Game.player,hi,null,i);window.Game.selectedCard=null;};}
                        if(o==='player'&&r&&!u&&c.data.type===TYPE.REACT){sl.classList.add('valid');sl.onclick=()=>{window.Game.playCard(window.Game.player,hi,null,i);window.Game.selectedCard=null;};}
                        if(((o==='player'&&c.data.target===TARGET.ALLY)||(o==='cpu'&&c.data.target===TARGET.ENEMY))&&!r&&u){sl.classList.add('valid');sl.onclick=()=>{window.Game.playCard(window.Game.player,hi,u);window.Game.selectedCard=null;};}
                    }
                    if(window.Game.phase===PHASE.BATTLE){
                        if(o==='player'&&u&&!r&&u.canAttack&&!u.hasAttacked){sl.style.cursor='pointer';sl.onclick=(e)=>{e.stopPropagation();window.Game.selectedUnit=u;this.update();this.log("Target?");};}
                        if(o==='cpu'&&!r&&u&&window.Game.selectedUnit){sl.classList.add('attack-target');sl.onclick=()=>{window.Game.attack(window.Game.selectedUnit,i);window.Game.selectedUnit=null;};}
                    }
                }
            });
            if(o==='cpu'&&!r&&window.Game.phase===PHASE.BATTLE&&window.Game.selectedUnit&&!l.some(u=>u)){ d.style.cursor='crosshair';d.onclick=(e)=>{if(e.target===d){window.Game.attack(window.Game.selectedUnit,-1);window.Game.selectedUnit=null;}}; }
        },
        c(c){
            const e=document.createElement('div');e.className=`card ${c.data.type.toLowerCase()}`;
            e.innerHTML=`<div class="card-name">${c.data.name}</div><div class="card-art">${c.data.icon}</div><div class="card-stats">${c.data.type===TYPE.UNIT?`<span class="val-atk">âš”${c.atk}</span><span class="val-def">ğŸ›¡${c.def}</span>`:''}</div>`;
            return e;
        },
        log(m){const d=document.createElement('div');d.className='log-line';d.innerText=m;document.getElementById('log-panel').prepend(d);},
        floatText(t,txt,c){
            const el=document.createElement('div');el.className='float-txt';el.innerText=txt;el.style.color=c;
            let p=null;
            if(t==='player-lp')p=document.querySelector('.player-lp');
            else if(t==='cpu-lp')p=document.querySelector('.enemy-lp');
            else if(t.uid){ const s=document.querySelectorAll('.slot'); s.forEach(sl=>{if(sl.firstChild&&sl.firstChild.innerText.includes(t.data.name))p=sl;});}
            if(p)p.appendChild(el);setTimeout(()=>el.remove(),1200);
        }
    };
</script>
</body>
</html>
