<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Arcana Flame - Gacha & Account</title>
    <style>
        /* --- ãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå‰å›ã¨åŒã˜ï¼‰ --- */
        :root { --bg-color: #121212; --panel-bg: #1e1e1e; --text-color: #e0e0e0; --accent-blue: #5c97f7; --accent-red: #f75c5c; --highlight: #ffd700; }
        body { margin: 0; background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        #app { display: flex; flex-direction: column; height: 100vh; max-width: 900px; margin: 0 auto; background: #000; border-left: 1px solid #333; border-right: 1px solid #333; }
        .hidden { display: none !important; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        button { cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: 0.2s; }
        
        /* --- ã‚¬ãƒãƒ£ï¼†ãƒ­ã‚°ã‚¤ãƒ³ç”¨ã‚¹ã‚¿ã‚¤ãƒ« --- */
        #login-screen, #gacha-screen { text-align: center; }
        .stone-display { font-size: 20px; color: var(--highlight); margin: 10px; border: 1px solid #444; padding: 5px 20px; border-radius: 20px; background: #222; }
        .gacha-btn { padding: 15px 40px; font-size: 18px; background: linear-gradient(45deg, #f1c40f, #e67e22); color: #000; margin: 10px; box-shadow: 0 0 15px rgba(241, 196, 15, 0.5); }
        .gacha-btn:hover { transform: scale(1.05); }
        .menu-btn { padding: 10px 20px; background: #444; color: #fff; margin: 5px; }
        .gacha-result { display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap; justify-content: center; }
        .user-info { position: absolute; top: 10px; right: 10px; font-size: 12px; color: #888; z-index: 300; text-align: right;}

        /* --- ã‚²ãƒ¼ãƒ å†…ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå‰å›æº–æ‹ ãƒ»çœç•¥ç‰ˆï¼‰ --- */
        .field-section { flex: 1; display: flex; flex-direction: column; justify-content: center; position: relative; padding: 5px; }
        .enemy-area { background: rgba(100, 30, 30, 0.2); border-bottom: 2px solid #333; }
        .player-area { background: rgba(30, 60, 100, 0.2); }
        .row { display: flex; justify-content: center; gap: 10px; min-height: 120px; align-items: center; }
        .hand-container { height: 130px; background: #0a0a0a; display: flex; justify-content: center; align-items: center; gap: 5px; overflow-x: auto; }
        .slot { width: 80px; height: 110px; border: 2px dashed #444; border-radius: 6px; position: relative; transition: 0.2s; }
        .card { width: 100%; height: 100%; background: var(--panel-bg); border: 2px solid #555; border-radius: 5px; display: flex; flex-direction: column; padding: 2px; font-size: 9px; cursor: pointer; position: relative; }
        .card.unit { border-top: 4px solid #a3b1b5; }
        .card.spell { border-top: 4px solid #b580d1; }
        .card.reaction { border-top: 4px solid #e08e45; }
        .card-name { font-weight: bold; text-align: center; white-space: nowrap; overflow: hidden; margin-bottom: 2px; }
        .card-art { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 24px; background: rgba(0,0,0,0.3); }
        .card-stats { display: flex; justify-content: space-between; font-weight: bold; font-size: 11px; padding: 0 2px; margin-top: auto;}
        .val-atk { color: #ff7777; } .val-def { color: #77aaff; }
        .center-hud { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; pointer-events: none; text-align: center;}
        #phase-badge { background: var(--accent-blue); color: #fff; padding: 5px 20px; border-radius: 15px; font-weight: bold; font-size: 18px; margin-bottom: 10px; }
        #btn-next { pointer-events: auto; background: #eee; color: #111; padding: 8px 25px; font-size: 14px; }
        #log-panel { position: absolute; bottom: 140px; right: 10px; width: 200px; height: 100px; background: rgba(0,0,0,0.8); border: 1px solid #444; overflow-y: auto; pointer-events: none; z-index: 50; font-size: 10px; color: #ccc; }
    </style>
</head>
<body>

<!-- ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±è¡¨ç¤º -->
<div class="user-info">
    <span id="user-name">Guest</span><br>
    ğŸ’ <span id="user-stones">0</span>
</div>

<!-- 1. ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ -->
<div id="login-screen" class="overlay">
    <h1>ARCANA FLAME</h1>
    <p>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ»ãƒ‡ãƒ¼ã‚¿ä¿å­˜å¯¾å¿œç‰ˆ</p>
    <button class="gacha-btn" onclick="Auth.login()">Googleã§ãƒ­ã‚°ã‚¤ãƒ³</button>
    <p style="font-size:12px; color:#aaa; margin-top:20px;">â€»ãƒ­ã‚°ã‚¤ãƒ³ã™ã‚‹ã¨ãƒ‡ãƒ¼ã‚¿ãŒä¿å­˜ã•ã‚Œã¾ã™</p>
</div>

<!-- 2. ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼†ã‚¬ãƒãƒ£ç”»é¢ -->
<div id="menu-screen" class="overlay hidden">
    <h2>MAIN MENU</h2>
    <div class="stone-display">æ‰€æŒé­”æ³•çŸ³: <span id="menu-stones">0</span></div>
    
    <div style="border:1px solid #444; padding:20px; border-radius:10px; background:#222; margin-bottom:20px;">
        <h3>ğŸ”® ã‚«ãƒ¼ãƒ‰ãƒ‘ãƒƒã‚¯ã‚¬ãƒãƒ£</h3>
        <p style="font-size:12px; color:#aaa;">1å› 100çŸ³ / å…¨26ç¨®</p>
        <button class="gacha-btn" onclick="Gacha.pull()">ã‚¬ãƒãƒ£ã‚’å¼•ã (100ğŸ’)</button>
        <button class="menu-btn" onclick="Gacha.addFreeStones()">ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹å—å– (+500ğŸ’)</button>
    </div>

    <div class="gacha-result" id="gacha-result"></div>

    <div style="margin-top:30px;">
        <h3>âš”ï¸ ãƒ‡ãƒƒã‚­é¸æŠã—ã¦ãƒãƒˆãƒ«</h3>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button class="menu-btn" onclick="Game.start(0)">çƒˆç«ã®ãƒ‰ãƒ©ã‚´ãƒ³</button>
            <button class="menu-btn" onclick="Game.start(1)">æŠ€å·§ã®é­”è¡“å¸«</button>
            <button class="menu-btn" onclick="Game.start(2)">é‰„å£ã®ãƒ“ãƒ¼ã‚¹ãƒˆ</button>
        </div>
    </div>
</div>

<!-- 3. ã‚²ãƒ¼ãƒ ç”»é¢ -->
<div id="game-app" class="hidden">
    <div class="field-section enemy-area">
        <div style="position:absolute; top:5px; left:5px; font-size:12px;">CPU LP: <span id="cpu-lp">12</span></div>
        <div class="row" id="cpu-units"><div class="slot" data-i="0"></div><div class="slot" data-i="1"></div><div class="slot" data-i="2"></div></div>
        <div class="row" id="cpu-reacts" style="min-height:80px;"><div class="slot reaction" data-i="0"></div><div class="slot reaction" data-i="1"></div></div>
    </div>
    <div class="center-hud">
        <div id="phase-badge">START</div>
        <button id="btn-next" onclick="Game.nextPhase()">Start</button>
    </div>
    <div class="field-section player-area">
        <div class="row" id="player-reacts" style="min-height:80px;"><div class="slot reaction" data-i="0"></div><div class="slot reaction" data-i="1"></div></div>
        <div class="row" id="player-units"><div class="slot" data-i="0"></div><div class="slot" data-i="1"></div><div class="slot" data-i="2"></div></div>
        <div style="position:absolute; bottom:5px; left:5px; font-size:12px;">YOU LP: <span id="player-lp">12</span></div>
    </div>
    <div class="hand-container" id="player-hand"></div>
    <div id="log-panel"></div>
    <button class="menu-btn" style="position:absolute; top:5px; left:5px; z-index:300;" onclick="location.reload()">RETIRE</button>
</div>

<!-- Firebase SDKs -->
<script type="module">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyCNgyBeSzbc74e6iWNnY0irswl24ciAfcg",
  authDomain: "arcana-flame-game.firebaseapp.com",
  projectId: "arcana-flame-game",
  storageBucket: "arcana-flame-game.firebasestorage.app",
  messagingSenderId: "562804440230",
  appId: "1:562804440230:web:26f7bd08ea47d39ad80867",
  measurementId: "G-XT2EDR06R1"
};


    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å…¬é–‹ï¼ˆHTMLãƒœã‚¿ãƒ³ã‹ã‚‰å‘¼ã¶ãŸã‚ï¼‰
    window.Auth = {
        user: null,
        async login() {
            try {
                const result = await signInWithPopup(auth, provider);
                // ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ã®å‡¦ç†ã¯ onAuthStateChanged ã§è¡Œã„ã¾ã™
            } catch (error) {
                console.error("Login Failed:", error);
                alert("ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼ã§å®Ÿè¡Œã—ã¦ã„ã¾ã™ã‹ï¼Ÿ(file://ã§ã¯å‹•ä½œã—ã¾ã›ã‚“)");
            }
        }
    };

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®çŠ¶æ…‹ç›£è¦–
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            window.Auth.user = user;
            document.getElementById('user-name').innerText = user.displayName;
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('menu-screen').classList.remove('hidden');
            
            // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ï¼ˆãªã‘ã‚Œã°ä½œæˆï¼‰
            await Gacha.loadUserData(user.uid);
        }
    });

    window.Gacha = {
        stones: 0,
        collection: [], // æŒã£ã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰IDãƒªã‚¹ãƒˆ

        async loadUserData(uid) {
            const userRef = doc(db, "users", uid);
            const docSnap = await getDoc(userRef);

            if (docSnap.exists()) {
                const data = docSnap.data();
                this.stones = data.stones || 0;
                this.collection = data.collection || [];
            } else {
                // åˆå›ç™»éŒ²ï¼šçŸ³3000å€‹ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ
                this.stones = 3000;
                this.collection = [];
                await setDoc(userRef, { stones: 3000, collection: [] });
            }
            this.updateDisplay();
        },

        updateDisplay() {
            document.getElementById('user-stones').innerText = this.stones;
            document.getElementById('menu-stones').innerText = this.stones;
        },

        async addFreeStones() {
            if(!window.Auth.user) return;
            const uid = window.Auth.user.uid;
            const userRef = doc(db, "users", uid);
            
            // ç”»é¢åæ˜ 
            this.stones += 500;
            this.updateDisplay();
            
            // DBä¿å­˜
            await updateDoc(userRef, {
                stones: increment(500)
            });
            alert("ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ 500å€‹ã‚’å—ã‘å–ã‚Šã¾ã—ãŸï¼");
        },

        async pull() {
            if (this.stones < 100) {
                alert("çŸ³ãŒè¶³ã‚Šã¾ã›ã‚“ï¼");
                return;
            }

            // çŸ³ã‚’æ¶ˆè²»
            this.stones -= 100;
            this.updateDisplay();

            // æŠ½é¸ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆDBã‚­ãƒ¼ä¸€è¦§ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
            const keys = Object.keys(DB);
            const hitId = keys[Math.floor(Math.random() * keys.length)];
            const cardData = DB[hitId];

            // ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«è¿½åŠ 
            this.collection.push(hitId);

            // DBæ›´æ–°
            const uid = window.Auth.user.uid;
            const userRef = doc(db, "users", uid);
            await updateDoc(userRef, {
                stones: increment(-100),
                collection: arrayUnion(hitId)
            });

            // çµæœè¡¨ç¤º
            const resDiv = document.getElementById('gacha-result');
            resDiv.innerHTML = `
                <div style="text-align:center; animation: pop 0.5s;">
                    <div style="font-size:12px; color:#888;">GET!</div>
                    <div class="card ${cardData.type === TYPE.UNIT ? 'unit' : (cardData.type === TYPE.SPELL ? 'spell' : 'reaction')}" style="width:80px; height:110px; margin:0 auto;">
                        <div class="card-name">${cardData.name}</div>
                        <div class="card-art">${cardData.icon}</div>
                        <div class="card-stats">
                            ${cardData.type===TYPE.UNIT ? `<span class="val-atk">âš”${cardData.atk}</span><span class="val-def">ğŸ›¡${cardData.def}</span>` : ''}
                        </div>
                    </div>
                </div>
            `;
        }
    };
</script>

<script>
    // --- ä»¥ä¸‹ã€å‰å›ã®ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆGame, UI, AI ãªã©ï¼‰ ---
    // â€»é•·ã„ã®ã§æ—¢å­˜ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ãã®ã¾ã¾ä½¿ç”¨ã—ã¾ã™ãŒã€Game.start()ã§ç”»é¢åˆ‡ã‚Šæ›¿ãˆã‚’è¿½åŠ ã—ã¾ã™

    const TYPE = { UNIT: 'UNIT', SPELL: 'SPELL', REACT: 'REACT' };
    const TARGET = { NONE: 'NONE', ENEMY: 'ENEMY', ALLY: 'ALLY', ANY: 'ANY' };
    const PHASE = { DRAW: 'DRAW', MAIN: 'MAIN', BATTLE: 'BATTLE', END: 'END' };

    // DB: å‰å›ã®ãƒ‡ãƒ¼ã‚¿ã¨åŒã˜ã‚‚ã®ã‚’ä½¿ç”¨
    const DB = {
        'd01': { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ãƒ»ãƒ‰ãƒ©ã‚´ãƒ³', type: TYPE.UNIT, atk: 3, def: 3, icon: 'ğŸ²', desc: '-', target: TARGET.NONE },
        'd02': { name: 'ãƒœãƒ«ã‚«ãƒ‹ãƒƒã‚¯ãƒ»ãƒ¯ã‚¤ãƒãƒ¼ãƒ³', type: TYPE.UNIT, atk: 4, def: 2, icon: 'ğŸ¦–', desc: '-', target: TARGET.NONE },
        'd03': { name: 'ã‚¬ãƒ¼ãƒ‰ã‚¹ã‚±ã‚¤ãƒ«ãƒ»ãƒ‰ãƒ©ã‚´ãƒ³', type: TYPE.UNIT, atk: 2, def: 5, icon: 'ğŸ›¡ï¸', desc: '-', target: TARGET.NONE },
        'd04': { name: 'ãƒ«ãƒ“ãƒ¼ãƒ›ãƒ¼ãƒ³ãƒ»ãƒ‰ãƒ©ã‚´ãƒ³', type: TYPE.UNIT, atk: 3, def: 4, icon: 'ğŸ‚', desc: '-', target: TARGET.NONE },
        'd05': { name: 'ã‚½ãƒ¼ãƒ©ãƒ¼ãƒ–ãƒ¬ã‚¤ã‚º', type: TYPE.UNIT, atk: 5, def: 3, icon: 'ğŸŒ', desc: 'å¬å–š:æ•µ2ãƒ€ãƒ¡', effect: 'dmg_2', target: TARGET.NONE },
        's01': { name: 'ãƒ‰ãƒ©ã‚´ãƒ³ãƒ»ãƒ•ã‚©ãƒ¼ã‚¹', type: TYPE.SPELL, icon: 'ğŸ’ª', desc: 'å‘³æ–¹ATK+2(T)', effect: 'buff_atk_2_turn', target: TARGET.ALLY },
        's02': { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ãƒãƒ¼ã‚¹ãƒˆ', type: TYPE.SPELL, icon: 'ğŸ”¥', desc: 'æ•µ3ãƒ€ãƒ¡', effect: 'dmg_3', target: TARGET.ENEMY },
        's03': { name: 'ç†±é¢¨ã®å·ä»¤', type: TYPE.SPELL, icon: 'ğŸŒ¬ï¸', desc: 'å…¨å‘³æ–¹ATK+1(T)', effect: 'all_atk_1_turn', target: TARGET.NONE },
        'r01': { name: 'ãƒ‰ãƒ©ã‚´ãƒ³ã®å’†å“®', type: TYPE.REACT, icon: 'ğŸ“¢', desc: 'è¢«å¼¾:ATK+1(T)', trigger: 'attacked', effect: 'react_atk_1' },
        'm01': { name: 'ã‚¢ãƒ¼ã‚¯ãƒ»ã‚¢ãƒ—ãƒ¬ãƒ³ãƒ†ã‚£ã‚¹', type: TYPE.UNIT, atk: 2, def: 2, icon: 'ğŸ§™', desc: 'å¬å–š:å‘³æ–¹DEF+1', effect: 'buff_def_1', target: TARGET.NONE },
        'm02': { name: 'ã‚¯ãƒ­ãƒãƒãƒ³ã‚µãƒ¼', type: TYPE.UNIT, atk: 1, def: 3, icon: 'â³', desc: 'æ°¸ç¶š:é­”è»½æ¸›1', passive: 'spell_resist', target: TARGET.NONE },
        'm03': { name: 'ãƒ«ãƒ¼ãƒ³ãƒ»ã‚¨ãƒ³ãƒãƒ£ãƒ³ã‚¿ãƒ¼', type: TYPE.UNIT, atk: 2, def: 3, icon: 'âœ¨', desc: 'æ°¸ç¶š:å‘³æ–¹ATK+1', passive: 'aura_atk_1', target: TARGET.NONE },
        'm04': { name: 'ãƒã‚®ã‚¢ãƒ»ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ã‚¹ãƒˆ', type: TYPE.UNIT, atk: 3, def: 2, icon: 'ğŸ“–', desc: 'å¬å–š:1ãƒ‰ãƒ­ãƒ¼', effect: 'draw_1', target: TARGET.NONE },
        'm05': { name: 'å¤§è³¢è€…ã‚ªãƒ«ãƒ‡ã‚£ãƒ³', type: TYPE.UNIT, atk: 4, def: 4, icon: 'ğŸ‘´', desc: 'å¬å–š:æ•µDEF-2', effect: 'debuff_def_2', target: TARGET.NONE },
        's11': { name: 'å°å°ã®é–ƒå…‰', type: TYPE.SPELL, icon: 'ğŸ”’', desc: 'æ•µæ”»æ’ƒä¸å¯(T)', effect: 'lock', target: TARGET.ENEMY },
        's12': { name: 'ãƒ‡ã‚£ã‚¹ã‚¸ãƒ£ãƒ³ã‚¯ã‚·ãƒ§ãƒ³', type: TYPE.SPELL, icon: 'ğŸš«', desc: 'æ•µATK0(T)', effect: 'zero_atk', target: TARGET.ENEMY },
        's13': { name: 'é­”å°è§£æ', type: TYPE.SPELL, icon: 'ğŸ“š', desc: '2ãƒ‰ãƒ­ãƒ¼', effect: 'draw_2', target: TARGET.NONE },
        's14': { name: 'ãƒãƒŠã‚·ãƒ¼ãƒ«ãƒ‰', type: TYPE.SPELL, icon: 'ğŸ›¡ï¸', desc: 'å‘³æ–¹ç ´å£Šç„¡åŠ¹(T)', effect: 'shield', target: TARGET.ALLY },
        'r11': { name: 'åè»¢ã®çµç•Œ', type: TYPE.REACT, icon: 'ğŸ›‘', desc: 'é­”æ³•ç„¡åŠ¹åŒ–', trigger: 'spell', effect: 'negate' },
        'r12': { name: 'ã‚¢ã‚¹ãƒˆãƒ©ãƒ«ã‚µã‚¤ã‚¯ãƒ«', type: TYPE.REACT, icon: 'ğŸŒŒ', desc: 'æ•µ3ä½“:2ä½“æˆ»ã™', trigger: 'full_field', effect: 'bounce_2' },
        'b01': { name: 'ã‚·ãƒ¼ãƒ«ãƒ‰ãƒ™ã‚¢', type: TYPE.UNIT, atk: 2, def: 5, icon: 'ğŸ»', desc: '-', target: TARGET.NONE },
        'b02': { name: 'ã‚¢ã‚¤ã‚¢ãƒ³ãƒ•ã‚¡ãƒ³ã‚°', type: TYPE.UNIT, atk: 3, def: 4, icon: 'ğŸº', desc: '-', target: TARGET.NONE },
        'b03': { name: 'ãƒªãƒšã‚¢ãƒ›ãƒ¼ãƒ³', type: TYPE.UNIT, atk: 1, def: 4, icon: 'ğŸ¦„', desc: 'å¬å–š:å‘³æ–¹DEF+2', effect: 'buff_def_2', target: TARGET.NONE },
        'b04': { name: 'ãƒ­ãƒƒã‚¯ã‚¸ãƒ£ã‚¦', type: TYPE.UNIT, atk: 3, def: 6, icon: 'ğŸ—¿', desc: '-', target: TARGET.NONE },
        'b05': { name: 'ã‚¿ã‚¤ã‚¿ãƒ³', type: TYPE.UNIT, atk: 4, def: 7, icon: 'ğŸ‘¹', desc: 'åæ’ƒ2ãƒ€ãƒ¡', passive: 'reflect', target: TARGET.NONE },
        's21': { name: 'ãƒ•ã‚©ãƒ¼ãƒˆãƒ¬ã‚¹', type: TYPE.SPELL, icon: 'ğŸ°', desc: 'å‘³æ–¹DEF+3', effect: 'buff_def_3', target: TARGET.ALLY },
        's22': { name: 'ã‚¢ã‚¤ã‚¢ãƒ³ã‚¹ãƒãƒƒã‚·ãƒ¥', type: TYPE.SPELL, icon: 'ğŸ”¨', desc: 'æ•µ2or4ãƒ€ãƒ¡', effect: 'cond_dmg', target: TARGET.ENEMY },
        's23': { name: 'ãƒãƒªã‚¢ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', type: TYPE.SPELL, icon: 'ğŸŒ', desc: 'å…¨å‘³æ–¹DEF+1(T)', effect: 'all_def_1_turn', target: TARGET.NONE },
        'r21': { name: 'å …ç‰¢ãªã‚‹åæ’ƒ', type: TYPE.REACT, icon: 'âš”ï¸', desc: 'è¢«å¼¾:æ•µ2ãƒ€ãƒ¡', trigger: 'attacked', effect: 'react_dmg_2' }
    };

    // ãƒ‡ãƒƒã‚­ãƒªã‚¹ãƒˆï¼ˆå›ºå®šï¼‰
    const DECK_LISTS = [
        ['d01','d01','d01', 'd02','d02','d02', 'd03','d03', 'd04','d04', 'd05','d05', 's01','s01', 's02','s02', 's03','s03', 'r01','r01'],
        ['m01','m01','m01', 'm02','m02', 'm03','m03','m03', 'm04','m04', 'm05','m05', 's11','s11', 's12','s12', 's13', 's14', 'r11', 'r12'],
        ['b01','b01','b01', 'b02','b02','b02', 'b03','b03', 'b04','b04', 'b05','b05', 's21','s21', 's22','s22', 's23','s23', 'r21','r21']
    ];

    class Card {
        constructor(id, owner) {
            this.id = id; this.data = DB[id]; this.owner = owner;
            this.uid = Math.random().toString(36).substr(2, 9);
            this.baseAtk = this.data.atk || 0; this.baseDef = this.data.def || 0;
            this.atkModPermanent = 0; this.atkModTurn = 0; this.defModPermanent = 0; this.defModTurn = 0; this.damageTaken = 0;
            this.canAttack = true; this.hasAttacked = false; this.isLocked = false; this.destructionImmune = false;
        }
        get atk() { return Math.max(0, this.baseAtk + this.atkModPermanent + this.atkModTurn + (this.passiveAtk || 0)); }
        get def() { return (this.baseDef + this.defModPermanent + this.defModTurn) - this.damageTaken; }
        resetTurn() { this.hasAttacked = false; this.canAttack = !this.isLocked; this.isLocked = false; this.destructionImmune = false; this.atkModTurn = 0; this.defModTurn = 0; }
    }

    const Game = {
        player: null, cpu: null, turn: 'player', phase: PHASE.DRAW, selectedCard: null, selectedUnit: null, gameOver: false, firstTurn: true,

        start(deckIdx) {
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-app').classList.remove('hidden');
            
            const createPlayer = (id, dIdx) => ({ id, lp: 12, deck: this.shuffle(DECK_LISTS[dIdx].map(cid => new Card(cid, id))), hand: [], units: [null, null, null], reacts: [null, null], summonCount: 0 });
            this.player = createPlayer('player', deckIdx);
            let cpuDeckIdx = (deckIdx + 1 + Math.floor(Math.random()*2)) % 3;
            this.cpu = createPlayer('cpu', cpuDeckIdx);

            for(let i=0; i<4; i++) { this.draw(this.player); this.draw(this.cpu); }
            this.turn = Math.random() < 0.5 ? 'player' : 'cpu';
            UI.log(`Game Start! å…ˆæ”»: ${this.turn.toUpperCase()}`);
            this.startTurn();
        },
        shuffle(arr) { for(let i=arr.length-1; i>0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; },
        draw(p, amt=1) { for(let i=0; i<amt; i++) { if(p.deck.length > 0) p.hand.push(p.deck.pop()); else this.endGame(p.id === 'player' ? 'cpu' : 'player'); } },
        startTurn() {
            this.phase = PHASE.DRAW;
            const p = this.turn === 'player' ? this.player : this.cpu;
            p.summonCount = 0;
            [this.player, this.cpu].forEach(pl => pl.units.forEach(u => { if(u) u.resetTurn(); }));
            this.updateStats(); UI.update();
            setTimeout(() => {
                if(this.firstTurn) { this.firstTurn = false; UI.log("å…ˆæ”»1T:ãƒ‰ãƒ­ãƒ¼ã‚¹ã‚­ãƒƒãƒ—"); } else { this.draw(p); }
                this.phase = PHASE.MAIN; UI.update();
                if(this.turn === 'cpu') AI.act();
            }, 800);
        },
        nextPhase() {
            if(this.gameOver) return;
            if(this.phase === PHASE.MAIN) { this.phase = PHASE.BATTLE; UI.update(); if(this.turn === 'cpu') AI.battle(); }
            else if(this.phase === PHASE.BATTLE) { this.phase = PHASE.END; this.turn = this.turn === 'player' ? 'cpu' : 'player'; this.startTurn(); }
        },
        playCard(p, handIdx, targetUnit=null, slotIdx=null) {
            const card = p.hand[handIdx]; if(!card) return;
            if(card.data.type === TYPE.UNIT) {
                if(p.summonCount >= 2) { UI.log("å¬å–šæ¨©ãªã—"); return; }
                if(p.units[slotIdx] !== null || p.units.some(u => u && u.data.name === card.data.name)) { UI.log("å¬å–šä¸å¯"); return; }
            }
            const opp = p.id === 'player' ? this.cpu : this.player;
            if(card.data.type === TYPE.SPELL && this.checkReaction('spell', opp, null)) { p.hand.splice(handIdx, 1); UI.log("ç„¡åŠ¹åŒ–"); UI.update(); return; }
            p.hand.splice(handIdx, 1);
            if(card.data.type === TYPE.UNIT) { p.units[slotIdx] = card; p.summonCount++; UI.log(`å¬å–š:${card.data.name}`); this.resolveEffect(card, p, null); this.checkReaction('full_field', opp, null); }
            else if(card.data.type === TYPE.SPELL) { UI.log(`ç™ºå‹•:${card.data.name}`); this.resolveEffect(card, p, targetUnit); }
            else if(card.data.type === TYPE.REACT) { p.reacts[slotIdx] = card; UI.log(`ã‚»ãƒƒãƒˆ:${card.data.name}`); }
            this.updateStats(); UI.update();
        },
        attack(attacker, targetIdx) {
            if(!attacker.canAttack || attacker.hasAttacked) return;
            attacker.hasAttacked = true;
            const defOwner = attacker.owner === 'player' ? this.cpu : this.player;
            const defender = targetIdx === -1 ? null : defOwner.units[targetIdx];
            if(defender && this.checkReaction('attacked', defOwner, defender)) { if(!attacker) return; }
            if(!defender) {
                if(defOwner.units.some(u => u !== null)) { UI.log("å£ã‚ã‚Š"); return; }
                UI.log(`${attacker.data.name} ç›´æ¥æ”»æ’ƒ`); this.damagePlayer(defOwner, attacker.atk);
            } else {
                UI.log(`æˆ¦é—˜:${attacker.atk} vs ${defender.def}`);
                if(defender.data.passive === 'reflect') { UI.log("åæ’ƒ"); this.damageUnit(attacker, 2); }
                if(attacker.atk > defender.def) { UI.log("æ’ƒç ´"); this.destroyUnit(defender); }
                else if (attacker.atk < defender.def) { UI.log("è¿”ã‚Šè¨ã¡"); this.destroyUnit(attacker); }
                else { UI.log("ç›¸æ‰“ã¡"); this.destroyUnit(attacker); this.destroyUnit(defender); }
            }
            this.updateStats(); UI.update();
        },
        resolveEffect(card, user, target) {
            const eff = card.data.effect; if(!eff) return;
            const opp = user.id === 'player' ? this.cpu : this.player;
            if(eff==='dmg_2') { const t = this.findBestTarget(opp.units, 'ATK'); if(t) this.damageUnit(t, 2); }
            else if(eff==='buff_def_1') card.defModPermanent += 1;
            else if(eff==='debuff_def_2') { const t = this.findBestTarget(opp.units, 'DEF'); if(t) this.damageUnit(t, 2); }
            else if(eff==='draw_1') this.draw(user, 1);
            else if(eff==='buff_def_2') card.defModPermanent += 2;
            else if(eff==='buff_atk_2_turn' && target) target.atkModTurn += 2;
            else if(eff==='dmg_3' && target) this.damageUnit(target, 3);
            else if(eff==='all_atk_1_turn') user.units.forEach(u=>{if(u) u.atkModTurn += 1;});
            else if(eff==='lock' && target) target.isLocked = true;
            else if(eff==='zero_atk' && target) target.atkModTurn = -target.baseAtk - target.atkModPermanent;
            else if(eff==='draw_2') this.draw(user, 2);
            else if(eff==='shield' && target) target.destructionImmune = true;
            else if(eff==='buff_def_3' && target) target.defModPermanent += 3;
            else if(eff==='cond_dmg' && target) { this.damageUnit(target, target.def >= 5 ? 4 : 2); }
            else if(eff==='all_def_1_turn') user.units.forEach(u=>{if(u) u.defModTurn += 1;});
            else if(eff==='react_atk_1' && target) target.atkModTurn += 1;
            else if(eff==='react_dmg_2') { const t = this.findBestTarget(opp.units, 'ATK'); if(t) this.damageUnit(t, 2); }
            else if(eff==='bounce_2') { let b = opp.units.filter(u=>u); for(let i=0;i<2;i++){ if(b.length===0)break; const idx=Math.floor(Math.random()*b.length); this.bounceUnit(b[idx]); b.splice(idx,1); } }
        },
        checkReaction(trigger, owner, targetUnit) {
            const idx = owner.reacts.findIndex(r => r && r.data.trigger === trigger); if(idx === -1) return false;
            const r = owner.reacts[idx];
            if(trigger==='full_field') { const opp = owner.id === 'player' ? this.cpu : this.player; if(opp.units.filter(u=>u).length < 3) return false; }
            UI.log(`ç½ :${r.data.name}`); this.resolveEffect(r, owner, targetUnit); owner.reacts[idx] = null; return true;
        },
        updateStats() {
            [this.player, this.cpu].forEach(p => {
                const hasEnchanter = p.units.some(u => u && u.data.passive === 'aura_atk_1');
                p.units.forEach(u => { if(u) u.passiveAtk = hasEnchanter ? 1 : 0; });
            });
        },
        damageUnit(u, amt) { if(u.data.passive === 'spell_resist') amt = Math.max(0, amt - 1); if(u.destructionImmune) { UI.log("ç„¡åŠ¹"); return; } u.damageTaken += amt; if(u.def <= 0) this.destroyUnit(u); },
        damagePlayer(p, amt) { p.lp -= amt; UI.update(); if(p.lp <= 0) this.endGame(p.id==='player'?'cpu':'player'); },
        destroyUnit(u) { if(u.destructionImmune){ UI.log("ç„¡åŠ¹"); return; } const o = u.owner === 'player' ? this.player : this.cpu; const i = o.units.indexOf(u); if(i !== -1) o.units[i] = null; },
        bounceUnit(u) { const o = u.owner === 'player' ? this.player : this.cpu; const i = o.units.indexOf(u); if(i !== -1) { o.units[i] = null; o.hand.push(new Card(u.id, u.owner)); UI.log("ãƒã‚¦ãƒ³ã‚¹"); } },
        findBestTarget(units, criteria) { const v = units.filter(u=>u); if(v.length===0) return null; if(criteria==='ATK') return v.sort((a,b)=>b.atk-a.atk)[0]; return v.sort((a,b)=>b.def-a.def)[0]; },
        endGame(winner) { this.gameOver = true; document.getElementById('result-screen').classList.remove('hidden'); document.getElementById('result-msg').innerText = winner === 'player' ? "YOU WIN!" : "YOU LOSE"; }
    };
    
    // AI & UI (Simplified for length)
    const AI={act(){if(Game.turn!=='cpu')return;const c=Game.cpu;const u=c.hand.map((x,i)=>({c:x,i})).filter(o=>o.c.data.type===TYPE.UNIT&&!c.units.some(k=>k&&k.data.name===o.c.data.name));if(u.length>0&&c.summonCount<2){u.sort((a,b)=>(b.c.atk+b.c.def)-(a.c.atk+a.c.def));const s=c.units.findIndex(k=>k===null);if(s!==-1){Game.playCard(c,u[0].i,null,s);setTimeout(()=>this.act(),600);return;}}const sp=c.hand.map((x,i)=>({c:x,i})).filter(o=>o.c.data.type!==TYPE.UNIT);if(sp.length>0){const s=sp[0];if(s.c.data.type===TYPE.REACT){const sl=c.reacts.findIndex(k=>k===null);if(sl!==-1)Game.playCard(c,s.i,null,sl);}else{let t=null;if(s.c.data.target===TARGET.ENEMY)t=Game.findBestTarget(Game.player.units,'ATK');if(s.c.data.target===TARGET.ALLY)t=Game.findBestTarget(c.units,'ATK');if(s.c.data.target===TARGET.NONE||t)Game.playCard(c,s.i,t);}}setTimeout(()=>Game.nextPhase(),1000);},battle(){if(Game.turn!=='cpu')return;const a=Game.cpu.units.filter(u=>u&&u.canAttack&&!u.hasAttacked);if(a.length===0){setTimeout(()=>Game.nextPhase(),500);return;}a.sort((x,y)=>y.atk-x.atk);const at=a[0];const e=Game.player.units.map((u,i)=>({u,i})).filter(o=>o.u);let ti=-2;if(e.length===0)ti=-1;else{const k=e.filter(x=>at.atk>x.u.def);if(k.length>0){k.sort((x,y)=>y.u.atk-x.u.atk);ti=k[0].i;}else{const tr=e.filter(x=>at.atk===x.u.def&&x.u.atk>=at.atk);if(tr.length>0)ti=tr[0].i;}}if(ti!==-2)Game.attack(at,ti);else at.hasAttacked=true;setTimeout(()=>this.battle(),1000);}};
    const UI={update(){this.d();const p=document.getElementById('player-hand');p.innerHTML='';Game.player.hand.forEach((c,i)=>{const e=this.c(c);e.onclick=()=>{if(Game.turn!=='player'||Game.phase!==PHASE.MAIN)return;if(Game.selectedCard===c){if(c.data.target===TARGET.NONE&&c.data.type===TYPE.SPELL){Game.playCard(Game.player,i);Game.selectedCard=null;}else Game.selectedCard=null;}else Game.selectedCard=c;this.update();};if(Game.selectedCard===c)e.classList.add('selected');p.appendChild(e);});this.f('cpu-units',Game.cpu.units,'cpu',0);this.f('cpu-reacts',Game.cpu.reacts,'cpu',1);this.f('player-units',Game.player.units,'player',0);this.f('player-reacts',Game.player.reacts,'player',1);const b=document.getElementById('btn-next');if(Game.phase===PHASE.MAIN){b.innerText="Battle";b.disabled=Game.turn!=='player';}else if(Game.phase===PHASE.BATTLE){b.innerText="End Turn";b.disabled=Game.turn!=='player';}else{b.innerText="Wait";b.disabled=true;}},d(){document.getElementById('player-lp').innerText=Game.player.lp;document.getElementById('cpu-lp').innerText=Game.cpu.lp;document.getElementById('player-deck').innerText=Game.player.deck.length;document.getElementById('cpu-deck').innerText=Game.cpu.deck.length;document.getElementById('cpu-hand').innerText=Game.cpu.hand.length;document.getElementById('summon-cnt').innerText=Game.player.summonCount;document.getElementById('phase-badge').innerText=Game.phase;},f(id,l,o,r){const d=document.getElementById(id);const s=d.querySelectorAll('.slot');s.forEach((sl,i)=>{sl.innerHTML='';sl.className=r?'slot reaction':'slot';sl.onclick=null;const u=l[i];if(u){const e=this.c(u);if(o==='cpu'&&r)e.classList.add('face-down');if(u.hasAttacked||u.isLocked)e.classList.add('exhausted');if(u.destructionImmune)e.classList.add('immune');if(Game.selectedUnit===u)e.classList.add('selected');sl.appendChild(e);}if(Game.turn==='player'){if(Game.phase===PHASE.MAIN&&Game.selectedCard){const c=Game.selectedCard;const hi=Game.player.hand.indexOf(c);if(o==='player'&&!r&&!u&&c.data.type===TYPE.UNIT&&Game.player.summonCount<2&&!Game.player.units.some(k=>k&&k.data.name===c.data.name)){sl.classList.add('valid');sl.onclick=()=>{Game.playCard(Game.player,hi,null,i);Game.selectedCard=null;};}if(o==='player'&&r&&!u&&c.data.type===TYPE.REACT){sl.classList.add('valid');sl.onclick=()=>{Game.playCard(Game.player,hi,null,i);Game.selectedCard=null;};}if(((o==='player'&&c.data.target===TARGET.ALLY)||(o==='cpu'&&c.data.target===TARGET.ENEMY))&&!r&&u){sl.classList.add('valid');sl.onclick=()=>{Game.playCard(Game.player,hi,u);Game.selectedCard=null;};}}if(Game.phase===PHASE.BATTLE){if(o==='player'&&u&&!r&&u.canAttack&&!u.hasAttacked){sl.style.cursor='pointer';sl.onclick=(e)=>{e.stopPropagation();Game.selectedUnit=u;this.update();this.log("Target?");};}if(o==='cpu'&&!r&&u&&Game.selectedUnit){sl.classList.add('attack-target');sl.onclick=()=>{Game.attack(Game.selectedUnit,i);Game.selectedUnit=null;};}}}});if(o==='cpu'&&!r&&Game.phase===PHASE.BATTLE&&Game.selectedUnit&&!l.some(u=>u)){d.style.cursor='crosshair';d.onclick=(e)=>{if(e.target===d){Game.attack(Game.selectedUnit,-1);Game.selectedUnit=null;}};}},c(c){const e=document.createElement('div');e.className=`card ${c.data.type.toLowerCase()}`;e.innerHTML=`<div class="card-name">${c.data.name}</div><div class="card-art">${c.data.icon}</div><div class="card-stats">${c.data.type===TYPE.UNIT?`<span class="val-atk">âš”${c.atk}</span><span class="val-def">ğŸ›¡${c.def}</span>`:''}</div>`;return e;},log(m){const d=document.createElement('div');d.className='log-line';d.innerText=m;document.getElementById('log-panel').prepend(d);}};
</script>
</body>
</html>
